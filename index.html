<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Narrative Flow Designer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Theme Variables */
        :root[data-theme="dark"] {
            --bg-primary: #1e1e1e;
            --bg-secondary: #2d2d30;
            --bg-tertiary: #1e1e1e;
            --border-primary: #3e3e42;
            --border-secondary: #3e3e42;
            --text-primary: #cccccc;
            --text-secondary: #888;
            --shadow: rgba(0, 0, 0, 0.4);
            --node-hover: #3e3e42;
            --input-bg: #1e1e1e;
            --connection-highlight: rgba(0, 122, 204, 0.1);
        }

        :root[data-theme="light"] {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f9f9f9;
            --border-primary: #d0d0d0;
            --border-secondary: #e0e0e0;
            --text-primary: #333333;
            --text-secondary: #666666;
            --shadow: rgba(0, 0, 0, 0.15);
            --node-hover: #f0f0f0;
            --input-bg: #ffffff;
            --connection-highlight: rgba(0, 122, 204, 0.08);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            overflow: hidden;
            transition: background 0.3s ease;
        }

        /* Viewport-sized canvas; world is moved via transforms (fast) */
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        #canvas-container.panning {
            cursor: grabbing;
        }

        #connection-canvas {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
        }

        /* Translated wrapper (pan). Keeps translation unscaled. */
        #world {
            position: absolute;
            inset: 0;
            z-index: 2;
            transform-origin: 0 0;
            will-change: transform;
        }

        /* Scaled world content (zoom). */
        #nodes-container {
            position: absolute;
            left: 0;
            top: 0;
            width: 1px;
            height: 1px;
            overflow: visible;
            transform-origin: 0 0;
            will-change: auto;
        }

        #nodes-container.zooming {
            will-change: transform;
        }

        .node {
            position: absolute;
            background: var(--bg-secondary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            min-width: 250px;
            max-width: 400px;
            box-shadow: 0 4px 12px var(--shadow);
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .node.selected {
            border-color: #007acc;
            box-shadow: 0 0 0 2px rgba(0, 122, 204, 0.3);
        }

        /* Attachment / docking visuals */
        .node.attached:not(.selected) {
            box-shadow: 0 0 0 1px rgba(39, 174, 96, 0.18), 0 0 12px var(--shadow);
        }

        /* Docked stacks (optimized)
   Keep node shape consistent (no border-radius mutations).
   A tiny overlap is handled in JS layout to avoid visible seams. */
        .node.attached {
            box-shadow: 0 2px 10px var(--shadow);
        }

        .node.attached:not(.selected) {
            outline: 1px solid rgba(39, 174, 96, 0.14);
            outline-offset: -1px;
        }

        /* Snap preview while dragging */

        /* Dock join styling (no ‚Äúmalforming‚Äù, deterministic) */
        .node.dock-join-top {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
            border-top-color: transparent;
            /* hides inner seam while keeping layout stable */
        }

        .node.dock-join-top .node-header {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
        }

        .node.dock-join-bottom {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            border-bottom-color: transparent;
            /* hides inner seam while keeping layout stable */
        }

        /* Don‚Äôt let shadows create ‚Äúgaps‚Äù inside a stack */
        .node.attached.dock-join-top,
        .node.attached.dock-join-bottom {
            box-shadow: 0 2px 10px var(--shadow);
        }


        .node.snap-target {
            box-shadow: 0 0 0 2px rgba(0, 122, 204, 0.25), 0 4px 12px var(--shadow);
        }

        .node.snap-preview {
            box-shadow: 0 0 0 2px rgba(230, 126, 34, 0.35), 0 4px 12px var(--shadow);
        }

        .node-header {
            background: #007acc;
            color: white;
            padding: 10px 15px;
            border-radius: 6px 6px 0 0;
            font-weight: bold;
            font-size: 13px;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            position: relative;
            backface-visibility: hidden;
            transform: translateZ(0);
        }

        .node-header.purple {
            background: #9b59b6;
        }

        .node-header.red {
            background: #e74c3c;
        }

        .node-header.green {
            background: #27ae60;
        }

        .node-header.orange {
            background: #e67e22;
        }

        .node-number {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            flex: 0 0 auto;
            backface-visibility: hidden;
            transform: translateZ(0);
        }

        .node-title {
            flex: 1 1 auto;
            cursor: text;
            min-width: 80px;
            backface-visibility: hidden;
            transform: translateZ(0);
        }

        .node-title-input {
            flex: 1 1 auto;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 13px;
            font-weight: bold;
            width: 100%;
        }

        .node-type-badge {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 10px;
            text-transform: uppercase;
            flex: 0 0 auto;
            backface-visibility: hidden;
            transform: translateZ(0);
        }

        .node-content {
            padding: 0;
        }

        .dialogue-line {
            padding: 8px 42px 8px 15px;
            border-bottom: 1px solid var(--border-secondary);
            color: var(--text-primary);
            font-size: 13px;
            position: relative;
            cursor: text;
            transition: background 0.2s;
        }

        .dialogue-line:last-child {
            border-bottom: none;
        }

        .dialogue-line:hover {
            background: var(--node-hover);
        }

        .dialogue-line.has-connection {
            background: var(--connection-highlight);
        }

        .line-speaker-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .line-speaker {
            color: #e67e22;
            font-weight: bold;
            font-size: 11px;
            text-transform: uppercase;
            cursor: text;
            flex-shrink: 0;
        }

        .speaker-input {
            background: rgba(230, 126, 34, 0.2);
            border: 1px solid #e67e22;
            color: #e67e22;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            width: 100px;
        }



        .speaker-select {
            background: rgba(230, 126, 34, 0.18);
            border: 1px solid rgba(230, 126, 34, 0.75);
            color: #e67e22;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            width: 140px;
            outline: none;
        }

        .speaker-select:focus {
            border-color: #e67e22;
        }

        .dialogue-text {
            display: block;
            white-space: pre-wrap;
            /* wrap and preserve newlines */
            overflow-wrap: anywhere;
            /* break long words/URLs */
            word-break: break-word;
            margin-bottom: 4px;
            outline: none;
            user-select: text;
        }

        .dialogue-text[contenteditable="true"]:focus {
            box-shadow: 0 0 0 2px rgba(0, 122, 204, 0.35);
            border-radius: 4px;
        }

        .dialogue-text[contenteditable="true"]:empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
        }

        .dialogue-input {
            width: 100%;
            background: var(--input-bg);
            border: 1px solid #007acc;
            color: var(--text-primary);
            padding: 6px 8px;
            border-radius: 3px;
            font-size: 13px;
            font-family: inherit;
            margin-bottom: 4px;
        }

        .line-controls {
            position: absolute;
            top: 6px;
            right: 6px;
            display: flex;
            gap: 6px;
            z-index: 12;
        }

        .line-delete-btn {
            opacity: 0;
            background: transparent;
            border: 1px solid transparent;
            color: var(--text-secondary);
            width: 18px;
            height: 18px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.18s ease, background 0.18s ease, border-color 0.18s ease, color 0.18s ease, transform 0.12s ease;
        }

        .line-delete-btn:hover {
            background: #e67e22;
            border-color: #e67e22;
            color: #fff;
            transform: scale(1.03);
        }

        .line-delete-btn:focus-visible {
            outline: 2px solid rgba(0, 122, 204, 0.55);
            outline-offset: 2px;
        }

        .dialogue-line:hover .line-delete-btn {
            opacity: 0.95;
        }

        .connection-point {
            position: absolute;
            right: -8px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            background: #007acc;
            border: 2px solid var(--bg-primary);
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
            transition: all 0.2s;
        }

        .connection-point:hover {
            width: 20px;
            height: 20px;
            right: -10px;
            background: #0098ff;
        }

        .connection-point.active {
            background: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .node-input-point {
            position: absolute;
            left: -8px;
            top: 20px;
            width: 16px;
            height: 16px;
            background: #888;
            border: 2px solid var(--bg-primary);
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
            transition: all 0.2s;
        }

        .node-input-point:hover {
            width: 20px;
            height: 20px;
            left: -10px;
        }

        .node-input-point.active {
            background: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .add-line-btn {
            padding: 10px;
            text-align: center;
            color: #007acc;
            cursor: pointer;
            border-top: 1px solid var(--border-secondary);
            font-size: 12px;
            transition: background 0.2s;
        }

        .add-line-btn:hover {
            background: var(--node-hover);
        }

        .controls {
            position: absolute;
            top: 16px;
            right: 16px;
            z-index: 1000;
            background: var(--bg-secondary);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid var(--border-primary);
            width: 300px;
            min-width: 240px;
            max-width: 60vw;
            max-height: 90vh;
            overflow-y: auto;
            transition: background 0.3s ease, border-color 0.3s ease;
        
            box-sizing: border-box;}

        
        /* Resizable right controls panel */
        #controlsResizer {
            position: absolute;
            left: -8px;
            top: 0;
            width: 12px;
            height: 100%;
            cursor: col-resize;
            touch-action: none;
            z-index: 1100;
        }
        #controlsResizer::before {
            content: '';
            position: absolute;
            left: 7px;
            top: 10px;
            bottom: 10px;
            width: 2px;
            background: var(--border-primary);
            opacity: 0.35;
            border-radius: 2px;
        }
        #controlsResizer:hover::before { opacity: 0.8; }
        body.resizing, body.resizing * {
            cursor: col-resize !important;
            user-select: none !important;
        }
.controls button {
            display: block;
            width: 100%;
            margin-bottom: 8px;
            padding: 8px 10px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .controls button:hover {
            background: #005a9e;
        }

        .controls button:last-child {
            margin-bottom: 0;
        }

        .controls button.danger {
            background: #e74c3c;
        }

        .controls button.danger:hover {
            background: #c0392b;
        }

        .controls button.success {
            background: #27ae60;
        }

        .controls button.success:hover {
            background: #229954;
        }

        .controls label {
            color: var(--text-secondary);
            font-size: 11px;
            text-transform: uppercase;
            display: block;
            margin-top: 8px;
            margin-bottom: 4px;
        }

        .controls hr {
            border: none;
            border-top: 1px solid var(--border-primary);
            margin: 15px 0;
        }

        .zoom-row {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
        }

        .zoom-row button {
            margin-bottom: 0;
            padding: 8px 0;
            width: 33%;
        }

        .zoom-readout {
            text-align: center;
            color: var(--text-secondary);
            font-size: 11px;
            margin-bottom: 10px;
        }

        .color-picker {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }

        .color-option:hover {
            border-color: #007acc;
        }

        .color-option.blue {
            background: #007acc;
        }

        .color-option.purple {
            background: #9b59b6;
        }

        .color-option.red {
            background: #e74c3c;
        }

        .color-option.green {
            background: #27ae60;
        }

        .color-option.orange {
            background: #e67e22;
        }

        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid var(--border-primary);
            color: var(--text-primary);
            font-size: 12px;
            max-width: 360px;
            z-index: 1000;
            transition: background 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }

        .info h3 {
            color: #007acc;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .info p {
            margin-bottom: 5px;
        }

        .save-indicator {
            font-size: 10px;
            color: var(--text-secondary);
            text-align: center;
            padding: 5px;
            margin-top: 10px;
        }

        .save-indicator.unsaved {
            color: #e67e22;
            font-weight: bold;
        }

        .save-indicator.saved {
            color: #27ae60;
        }

        .node-type-selector {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .node-type-btn {
            flex: 1;
            padding: 8px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-primary);
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
            transition: all 0.2s;
        }

        .node-type-btn:hover {
            border-color: #007acc;
            color: var(--text-primary);
        }

        .node-type-btn.active {
            background: #007acc;
            border-color: #007acc;
            color: white;
            font-weight: bold;
        }

        #fileInput {
            display: none;
        }

        .theme-toggle {
            background: var(--bg-tertiary);
            border: 2px solid var(--border-primary);
            color: var(--text-primary);
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            margin-bottom: 10px;
        }

        .theme-toggle:hover {
            border-color: #007acc;
            background: var(--node-hover);
        }

        .theme-icon {
            margin-right: 5px;
        }


        /* ---- App layout: Sidebar + Main ---- */
        #app {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        #sidebar {
            width: var(--sidebar-w, 280px);
            min-width: 200px;
            max-width: 560px;
            background: var(--bg-secondary);
            border-right: 2px solid var(--border-primary);
            display: flex;
            flex-direction: column;
            position: relative;
            user-select: none;
        }

        #sidebar.collapsed {
            width: 44px !important;
            min-width: 44px !important;
            max-width: 44px !important;
        }

        #sidebar.collapsed .sb-title,
        #sidebar.collapsed .sb-search,
        #sidebar.collapsed .sb-tree,
        #sidebar.collapsed .sb-footer {
            display: none;
        }

        #sidebar.collapsed #sbResizer {
            display: none;
        }

        .sb-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 10px;
            border-bottom: 1px solid var(--border-primary);
        }

        .sb-title {
            color: var(--text-primary);
            font-weight: 700;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .sb-icon-btn {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 1px solid var(--border-primary);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            transition: background 0.15s, border-color 0.15s;
            display: grid;
            place-items: center;
        }

        .sb-icon-btn:hover {
            background: var(--node-hover);
            border-color: #007acc;
        }

        .sb-search {
            padding: 10px;
            border-bottom: 1px solid var(--border-primary);
        }

        .sb-search input {
            width: 100%;
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid var(--border-primary);
            background: var(--input-bg);
            color: var(--text-primary);
            outline: none;
            font-size: 12px;
        }

        .sb-search input:focus {
            border-color: #007acc;
        }

        .sb-tree {
            flex: 1 1 auto;
            overflow: auto;
            padding: 8px 6px 12px 6px;
        }

        .tree-row {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 12px;
        }

        .tree-row[draggable="true"] {
            cursor: grab;
        }

        .tree-row.dragging {
            opacity: 0.55;
        }

        .tree-row.drop-target {
            outline: 1px dashed rgba(0, 122, 204, .7);
            background: rgba(0, 122, 204, .12);
        }

        .tree-row.drop-deny {
            outline: 1px dashed rgba(220, 60, 60, .7);
            background: rgba(220, 60, 60, .10);
        }

        .tree-row:hover {
            background: var(--node-hover);
        }

        .tree-row.selected {
            background: rgba(0, 122, 204, 0.18);
            outline: 1px solid rgba(0, 122, 204, 0.25);
        }

        .tree-twist {
            width: 16px;
            height: 16px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: grid;
            place-items: center;
            border-radius: 4px;
            flex: 0 0 auto;
        }

        .tree-twist:hover {
            background: rgba(255, 255, 255, 0.06);
            color: var(--text-primary);
        }

        .tree-twist.spacer {
            opacity: 0;
            pointer-events: none;
        }

        .tree-icon {
            width: 16px;
            text-align: center;
            opacity: 0.95;
            flex: 0 0 auto;
        }

        .tree-name {
            flex: 1 1 auto;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tree-rename {
            width: 100%;
            padding: 4px 6px;
            border-radius: 5px;
            border: 1px solid #007acc;
            background: var(--input-bg);
            color: var(--text-primary);
            outline: none;
            font-size: 12px;
        }

        .tree-children {
            margin-left: 18px;
        }

        .sb-footer {
            padding: 10px;
            border-top: 1px solid var(--border-primary);
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .sb-btn {
            padding: 9px 10px;
            border-radius: 6px;
            border: 1px solid var(--border-primary);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
            transition: background 0.15s, border-color 0.15s;
        }

        .sb-btn:hover {
            background: var(--node-hover);
            border-color: #007acc;
        }

        .sb-add {
            position: relative;
        }

        .sb-add-btn {
            width: 100%;
        }

        .sb-delete-btn {
            border-color: rgba(220, 60, 60, 0.45);
            background: rgba(220, 60, 60, 0.10);
        }

        .sb-delete-btn:hover {
            border-color: rgba(220, 60, 60, 0.85);
            background: rgba(220, 60, 60, 0.18);
        }


        .sb-add-menu {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 44px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 10px;
            padding: 6px;
            box-shadow: 0 12px 28px var(--shadow);
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 200;
        }

        .sb-menu-item {
            text-align: left;
            padding: 9px 10px;
            border-radius: 8px;
            border: 1px solid transparent;
            background: transparent;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
        }

        .sb-menu-item:hover {
            background: var(--node-hover);
            border-color: rgba(0, 122, 204, 0.25);
        }

        .sb-menu-sep {
            height: 1px;
            background: var(--border-primary);
            opacity: 0.7;
            margin: 4px 6px;
        }

        #sbResizer {
            position: absolute;
            top: 0;
            right: -4px;
            width: 8px;
            height: 100%;
            cursor: col-resize;
            z-index: 50;
        }

        /* Main area */
        #main {
            flex: 1 1 auto;
            position: relative;
            overflow: hidden;
        }

        #main-header {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--border-primary);
            color: var(--text-primary);
            font-size: 12px;
        }

        .crumbs {
            opacity: 0.95;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 70vw;
        }

        .mh-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mh-btn {
            padding: 7px 10px;
            border-radius: 6px;
            border: 1px solid var(--border-primary);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
            transition: background 0.15s, border-color 0.15s;
        }

        .mh-btn:hover {
            background: var(--node-hover);
            border-color: #007acc;
        }

        .mh-btn.mh-compact {
            padding: 6px 8px;
            font-size: 11px;
            line-height: 1;
        }

        .mh-sep {
            width: 1px;
            height: 18px;
            background: var(--border-primary);
            opacity: 0.6;
        }

        .mh-zoom {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .mh-zoom-btn {
            min-width: 30px;
            text-align: center;
        }

        .mh-zoom-readout {
            min-width: 56px;
        }

        .mh-theme-btn {
            min-width: 62px;
            text-align: center;
        }

        .mh-btn.danger-outline {
            border-color: rgba(231, 76, 60, 0.6);
        }

        .mh-btn.danger-outline:hover {
            border-color: rgba(231, 76, 60, 1);
            background: rgba(231, 76, 60, 0.12);
        }

        #main-content {
            position: absolute;
            left: 0;
            right: 0;
            top: 40px;
            bottom: 0;
            overflow: hidden;
        }

        .view-pane {
            position: absolute;
            inset: 0;
            display: none;
            overflow: hidden;
        }

        .view-pane.active {
            display: block;
        }

        /* Entity editor */
        .entity-editor {
            height: 100%;
            overflow: auto;
            padding: 16px;
            color: var(--text-primary);
        }

        .entity-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 14px;
        }

        .entity-kind {
            font-size: 13px;
            font-weight: 800;
            opacity: 0.95;
        }

        .entity-form {
            max-width: 860px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 170px 1fr;
            gap: 12px;
            align-items: start;
            margin-bottom: 12px;
        }

        .form-row label {
            color: var(--text-secondary);
            font-size: 11px;
            text-transform: uppercase;
            padding-top: 10px;
        }

        .form-row input,
        .form-row textarea {
            width: 100%;
            border-radius: 8px;
            border: 1px solid var(--border-primary);
            background: var(--input-bg);
            color: var(--text-primary);
            padding: 10px 12px;
            font-size: 13px;
            outline: none;
        }

        .form-row input:focus,
        .form-row textarea:focus {
            border-color: #007acc;
        }

        .form-row textarea {
            resize: vertical;
            line-height: 1.35;
        }

        .half-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .codebox {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            tab-size: 4;
        }
    
        /* =========================
           Variable tokens & previews
           ========================= */
        .dialogue-var-preview{
            display:none;
            margin-top:4px;
            font-size:11px;
            color:var(--text-secondary);
            opacity:0.9;
            white-space:pre-wrap;
        }

        .line-var-btn{
            opacity:0;
            background:transparent;
            border:1px solid transparent;
            color:var(--text-secondary);
            width:26px;
            height:18px;
            border-radius:6px;
            cursor:pointer;
            font-size:11px;
            line-height:1;
            display:inline-flex;
            align-items:center;
            justify-content:center;
            transition: opacity 0.18s ease, background 0.18s ease, border-color 0.18s ease, color 0.18s ease, transform 0.12s ease;
        }

        .dialogue-line:hover .line-var-btn{ opacity:0.95; }

        .line-var-btn:hover{
            background:#2d7dd2;
            border-color:#2d7dd2;
            color:#fff;
            transform:scale(1.03);
        }

        .inline-var-picker{
            position:fixed;
            z-index:99999;
            padding:6px;
            border:1px solid var(--border-secondary);
            border-radius:10px;
            background:var(--input-bg);
            color:var(--text-primary);
            font-size:12px;
            box-shadow:0 10px 25px rgba(0,0,0,0.35);
            max-width:260px;
        }

        /* Connection picker controls */
        #connPickerBlock button{
            display:inline-flex;
            width:34px;
            margin-bottom:0;
            padding:6px 0;
            align-items:center;
            justify-content:center;
        }
        #connPickerBlock select{
            margin-bottom:0;
        }

</style>
</head>

<body>
    <div id="app">
        <aside id="sidebar" aria-label="Project sidebar">
            <div class="sb-header">
                <button id="sbToggle" class="sb-icon-btn" title="Collapse sidebar">‚ò∞</button>
                <div class="sb-title" id="projectTitle">Project</div>
            </div>
            <div class="sb-search">
                <input id="sbSearch" type="text" placeholder="Search‚Ä¶" />
            </div>
            <div id="sbTree" class="sb-tree" role="tree"></div>
            <div class="sb-footer">
                <div class="sb-add">
                    <button id="sbAddBtn" class="sb-btn sb-add-btn">+ Add</button>
                    <div id="sbAddMenu" class="sb-add-menu" hidden>
                        <button class="sb-menu-item" data-add="folder">üìÅ New Folder</button>
                        <div class="sb-menu-sep"></div>
                        <button class="sb-menu-item" data-add="graph">üß† New Graph</button>
                        <button class="sb-menu-item" data-add="character">üë§ New Character</button>
                        <button class="sb-menu-item" data-add="item">üéí New Item</button>
                        <button class="sb-menu-item" data-add="location">üìç New Location</button>
                        <button class="sb-menu-item" data-add="variable">üíé New Variable</button>
                        <button class="sb-menu-item" data-add="note">üìù New Note</button>
                    </div>
                </div>
                <button id="sbDeleteBtn" class="sb-btn sb-delete-btn" title="Delete selected item/folder">üóë
                    Delete</button>
            </div>
            <div id="sbResizer" title="Drag to resize"></div>
        </aside>

        <div id="main">
            <div id="main-header">
                <div class="mh-left">
                    <div id="crumbs" class="crumbs">Views ‚ñ∏ Main Flow</div>
                </div>
                <div class="mh-right">
                    <button id="mhGoGraph" class="mh-btn" title="Jump to current graph">Graph</button>
                    <button id="mhAddNode" class="mh-btn" title="Add a node near the center">+ Node</button>
                    <div class="mh-sep" aria-hidden="true"></div>
                    <div class="mh-zoom" role="group" aria-label="Zoom controls">
                        <button class="mh-btn mh-compact mh-zoom-btn" onclick="zoomOut()" title="Zoom out">-</button>
                        <button class="mh-btn mh-compact mh-zoom-btn mh-zoom-readout" onclick="resetView()" title="Reset view"><span id="zoomText">100%</span></button>
                        <button class="mh-btn mh-compact mh-zoom-btn" onclick="zoomIn()" title="Zoom in">+</button>
                    </div>
                    <button id="mhThemeToggle" class="mh-btn mh-compact mh-theme-btn" onclick="toggleTheme()" title="Switch to Light mode" aria-label="Toggle theme">
                        <span id="themeText">Light</span>
                    </button>
                </div>
            </div>

            <div id="main-content">
                <div id="graph-pane" class="view-pane active">
                    <div id="canvas-container">
                        <canvas id="connection-canvas"></canvas>
                        <div id="world">
                            <div id="nodes-container"></div>
                        </div>
                    </div>
                    <div class="controls" id="rightControlsPanel">
                        <div id="controlsResizer" title="Drag to resize"></div>
                        <button onclick="fitView()" class="success" title="Fit nodes to the viewport (F)">Fit to
                            Nodes</button>

                        <hr>

                        <button onclick="deleteSelectedNode()" class="danger">Delete Node</button>

                        <label>Node Type:</label>
                        <div class="node-type-selector">
                            <div class="node-type-btn" onclick="changeNodeType('normal')">Normal</div>
                            <div class="node-type-btn" onclick="changeNodeType('character')">Character</div>
                        </div>

                        

<label>On Enter: Variable Actions:</label>
<div id="nodeActionsList" style="margin-top:8px; display:flex; flex-direction:column; gap:6px;"></div>
<div style="display:flex; gap:6px; margin-top:6px;">
  <button id="addNodeActionBtn" title="Add action">+ Add</button>
  <button id="simulateEnterNodeBtn" class="success" title="Apply actions for the selected node">Enter Node (Simulate)</button>
</div>
<div style="margin-top:6px; font-size:11px; color:var(--text-secondary); line-height:1.35;">
  Tip: <b>{{varName}}</b> tokens in dialogue are for <i>display</i>. Variable changes happen via <b>Traverse</b> (connections) or these <b>On Enter</b> actions.
</div>

<label>Node Color:</label>
                        <div class="color-picker">
                            <div class="color-option blue" onclick="changeNodeColor('blue')"></div>
                            <div class="color-option purple" onclick="changeNodeColor('purple')"></div>
                            <div class="color-option red" onclick="changeNodeColor('red')"></div>
                            <div class="color-option green" onclick="changeNodeColor('green')"></div>
                            <div class="color-option orange" onclick="changeNodeColor('orange')"></div>
                        </div>

                        <div id="connectionProperties" style="display:block;">
                            <hr>
                             <div id="connPickerBlock">
                                 <div style="font-size:11px; color:var(--text-secondary); line-height:1.35; margin:6px 0 8px;">
                                     Pick a connection to edit it (or click a line in the graph). The <b>Traverse</b> button appears once a connection is selected.
                                 </div>
                                 <div style="display:flex; gap:6px; align-items:center; margin-bottom:6px;">
                                     <select id="connPicker" style="flex:1; padding:8px; border:1px solid var(--border-secondary); border-radius:10px; background:var(--input-bg); color:var(--text-primary); font-size:12px;">
                                         <option value="">-- Select connection --</option>
                                     </select>
                                     <button id="connPrevBtn" title="Previous connection">‚óÄ</button>
                                     <button id="connNextBtn" title="Next connection">‚ñ∂</button>
                                 </div>
                                 <div id="connPickerMeta" style="font-size:11px; color:var(--text-secondary); margin-bottom:8px;"></div>
                             </div>
                            
<label>Conditions:</label>

<div style="display:flex; gap:6px; margin-top:6px; align-items:center;">
  <select id="connLogic" style="width:140px; padding:6px; border-radius:6px; border:1px solid var(--border-secondary); background:var(--input-bg); color:var(--text-primary); font-size:12px;">
    <option value="AND">ALL (AND)</option>
    <option value="OR">ANY (OR)</option>
  </select>
  <button id="addConnConditionBtn" title="Add condition" style="width:34px;">+</button>
</div>

<div id="connConditionsList" style="margin-top:8px; display:flex; flex-direction:column; gap:6px;"></div>

<div style="margin-top:10px;">
  <label style="font-size:10px;">Manual expression (optional):</label>
  <textarea id="connCondition" rows="2" placeholder="e.g. {{statMechanic}} => 3 and {{NicoMood}} => 10"
    style="width:100%; border-radius:8px; border:1px solid var(--border-secondary); background:var(--input-bg); color:var(--text-primary); padding:6px; font-size:12px; margin-top:4px;"></textarea>
</div>

<div id="conditionPreview"
  style="margin-top:8px; padding:8px; border-radius:8px; background:var(--panel-secondary); font-size:11px; border:1px solid var(--border-secondary);">
</div>

<hr style="margin:12px 0;">

                            <label>Set Variable on Traverse:</label>
                            <div style="display:flex; gap:6px; margin-top:6px; align-items:center;">
                                <select id="connSetVar"
                                    style="flex:1; padding:6px; border-radius:4px; border:1px solid var(--border-primary); background:var(--input-bg); color:var(--text-primary); font-size:12px;">
                                    <option value="">-- None --</option>
                                </select>
                                <span style="color:var(--text-secondary);">=</span>
                                <input id="connSetValue" type="text" placeholder="new value"
                                    style="width:80px; padding:6px; border-radius:4px; border:1px solid var(--border-primary); background:var(--input-bg); color:var(--text-primary); font-size:12px;" />
                            </div>

                            <button id="traverseConnBtn" class="success" style="margin-top:12px; width:100%;">Traverse
                                (Simulate)</button>
                            <button id="deleteConnBtn" class="danger" style="margin-top:8px;">Delete Connection</button>
                        </div>

                        <hr>

                        <button onclick="saveToFile()">üíæ Save (Ctrl+S)</button>
                        <button onclick="triggerLoadFile()">üìÇ Load from File</button>
                        <input type="file" id="fileInput" accept=".json" onchange="loadFromFile(event)">

                        <hr>

                        <button onclick="clearConnections()">Clear Connections</button>
                        <button onclick="exportData()">Export JSON</button>
                        <button onclick="resetDemo()">Reset Demo</button>

                        <div class="save-indicator" id="saveIndicator">No changes</div>
                    </div>
                    <div class="info">
                        <h3>Interactive Editor</h3>
                        <p><strong>Double-click empty space</strong> to add node</p>
                        <p><strong>Drag empty space</strong> to pan</p>
                        <p><strong>Mouse wheel</strong> to zoom</p>
                        <p><strong>F</strong> fits nodes to view</p>
                        <p><strong>Click ‚óè</strong> to connect (either side)</p>
                        <p><strong>Right-click ‚óè</strong> to delete a connection</p>
                        <p><strong>Drag headers</strong> to move nodes</p>
                        <p><strong>Click text</strong> to edit</p>
                        <p><strong>Ctrl+S</strong> to save</p>
                    </div>
                </div>

                <div id="entity-pane" class="view-pane">
                    <div id="entity-editor" class="entity-editor">
                        <div class="entity-top">
                            <div class="entity-kind" id="entityKind">Entity</div>
                            <div class="entity-actions">
                                <button id="entityBack" class="mh-btn">Back to Graph</button>
                                <button id="entityDelete" class="mh-btn danger-outline"
                                    title="Delete this item">Delete</button>
                            </div>
                        </div>

                        <div class="entity-form">
                            <div class="form-row">
                                <label>Name</label>
                                <input id="entName" type="text" />
                            </div>

                            <div class="form-row" id="rowTech">
                                <label>Technical name</label>
                                <input id="entTech" type="text" placeholder="e.g. Item_BananaWithSleepingPills" />
                            </div>

                            <div class="form-row" id="rowObjId">
                                <label>Object ID</label>
                                <input id="entObjectId" type="text" placeholder="Optional" />
                            </div>

                            <div class="form-row" id="rowVarType">
                                <label>Variable Type</label>
                                <select id="entVarType">
                                    <option value="boolean">Boolean</option>
                                    <option value="number">Number</option>
                                    <option value="string">String</option>
                                </select>
                            </div>

                            <div class="form-row" id="rowVarValue">
                                <label>Initial Value</label>
                                <input id="entVarValue" type="text" placeholder="Default value" />
                            </div>

                            <div class="form-row" id="rowRuntimeValue" style="display:none;">
                                <label>Runtime Value</label>
                                <div style="display:flex; gap:8px;">
                                    <input id="entRuntimeValue" type="text" />
                                    <button id="btnResetVar" class="mh-btn" title="Reset to initial value"
                                        style="padding: 0 10px;">‚Ü∫</button>
                                </div>
                            </div>

                            <div class="form-row" id="rowHalf">
                                <label>Details</label>
                                <div class="half-grid">
                                    <div>
                                        <div
                                            style="color: var(--text-secondary); font-size: 11px; text-transform: uppercase; margin-bottom: 6px;">
                                            Quantity</div>
                                        <input id="entQty" type="number" step="1" />
                                    </div>
                                    <div>
                                        <div
                                            style="color: var(--text-secondary); font-size: 11px; text-transform: uppercase; margin-bottom: 6px;">
                                            Tags</div>
                                        <input id="entTags" type="text" placeholder="comma separated" />
                                    </div>
                                </div>
                            </div>

                            <div class="form-row">
                                <label>Description / Notes</label>
                                <textarea id="entDesc" rows="12"></textarea>
                            </div>

                            <div class="form-row">
                                <label>Code / Script</label>
                                <textarea id="entCode" rows="8" class="codebox"
                                    placeholder="// Optional snippets, conditions, IDs‚Ä¶"></textarea>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('connection-canvas');
        const ctx = canvas.getContext('2d');
        const nodesContainer = document.getElementById('nodes-container');
        const canvasContainer = document.getElementById('canvas-container');
        const world = document.getElementById('world');
        const supportsCssZoom = typeof document.documentElement.style.zoom !== 'undefined';
        const useCssZoom = false;

        // ---- Sidebar / panes (Articy-style) ----
        const graphPane = document.getElementById('graph-pane');
        const entityPane = document.getElementById('entity-pane');
        const sidebar = document.getElementById('sidebar');
        const sbTree = document.getElementById('sbTree');
        const sbSearch = document.getElementById('sbSearch');
        const sbToggle = document.getElementById('sbToggle');
        const sbResizer = document.getElementById('sbResizer');
        const projectTitleEl = document.getElementById('projectTitle');
        const crumbsEl = document.getElementById('crumbs');

        const sbAddBtn = document.getElementById('sbAddBtn');
        const sbAddMenu = document.getElementById('sbAddMenu');
        const sbDeleteBtn = document.getElementById('sbDeleteBtn');

        const mhGoGraph = document.getElementById('mhGoGraph');
        const mhAddNode = document.getElementById('mhAddNode');

        const entityKindEl = document.getElementById('entityKind');
        const entName = document.getElementById('entName');
        const entTech = document.getElementById('entTech');
        const entObjectId = document.getElementById('entObjectId');
        const entQty = document.getElementById('entQty');
        const entTags = document.getElementById('entTags');
        const entDesc = document.getElementById('entDesc');
        const entCode = document.getElementById('entCode');
        const rowTech = document.getElementById('rowTech');
        const rowObjId = document.getElementById('rowObjId');
        const rowHalf = document.getElementById('rowHalf');

        const entityBackBtn = document.getElementById('entityBack');
        const entityDeleteBtn = document.getElementById('entityDelete');

        function isGraphActivePane() { return graphPane && graphPane.classList.contains('active'); }


        let nodes = [];
        let connections = [];

        let selectedEndpoint = null; // { type: 'output'|'input', nodeId, lineIndex? }
        let selectedConnection = null;
        let lastPointerScreen = { x: 0, y: 0 }; // viewport coords (px) for ghost wiring
        let selectedNode = null;

        let isDragging = false;
        let draggedNode = null;
        let dragOffset = { x: 0, y: 0 };
        let didMoveNode = false;

        let isPanning = false;
        let panStart = { x: 0, y: 0, panX: 0, panY: 0 };

        let nodeIdCounter = 0;
        let hasUnsavedChanges = false;
        let lastSavedState = null;
        let currentTheme = 'dark';
        let attachOrderCounter = 0;

        // ---- Runtime Variable State (for skill checks) ----
        let runtimeVariables = {};

        function initRuntimeVariables() {
            runtimeVariables = {};
            if (!project?.entities?.variables) return;
            for (const v of project.entities.variables) {
                let val = v.initialValue;
                if (v.varType === 'number') val = parseFloat(val) || 0;
                else if (v.varType === 'boolean') val = (val === 'true' || val === true);
                else val = String(val || '');
                runtimeVariables[v.name] = val;
            }
            refreshNodeVariablePreviews();
        }

        
        function resolveVariableName(varName) {
            if (!varName) return null;
            const raw = String(varName).trim();
            if (!raw) return null;

            // Exact match in runtime state
            if (raw in runtimeVariables) return raw;

            const lower = raw.toLowerCase();

            // Case-insensitive match in runtime state
            const rtKey = Object.keys(runtimeVariables).find(k => String(k).toLowerCase() === lower);
            if (rtKey) return rtKey;

            // If a display label like "name: value" sneaks in, try just the name.
            if (raw.includes(':')) {
                const base = raw.split(':')[0].trim();
                if (base) {
                    if (base in runtimeVariables) return base;
                    const baseLower = base.toLowerCase();
                    const rtBase = Object.keys(runtimeVariables).find(k => String(k).toLowerCase() === baseLower);
                    if (rtBase) return rtBase;
                }
            }

            // Case-insensitive match in project definition
            const v = project?.entities?.variables?.find(x => String(x?.name || '').toLowerCase() === lower);
            return v ? v.name : null;
        }

        function getVariableValue(varName) {
            const resolved = resolveVariableName(varName);
            if (!resolved) return undefined;

            if (resolved in runtimeVariables) return runtimeVariables[resolved];

            // Fallback to project definition
            const v = project?.entities?.variables?.find(x => x.name === resolved);
            if (!v) return undefined;
            if (v.varType === 'number') return parseFloat(v.initialValue) || 0;
            if (v.varType === 'boolean') return v.initialValue === 'true' || v.initialValue === true;
            return v.initialValue || '';
        }



        // --- Variable tokens inside node text ---
        let __inlineVarPickerEl = null;

        function interpolateVariables(text) {
            if (!text) return '';
            return String(text).replace(/\{\{\s*([A-Za-z_]\w*)\s*\}\}/g, (m, name) => {
                const val = getVariableValue(name);
                if (val === undefined || val === null) return '';
                return String(val);
            });
        }

        function refreshNodeVariablePreviews() {
            // Update any rendered previews in the graph nodes
            document.querySelectorAll('.dialogue-line').forEach(lineDiv => {
                const textEl = lineDiv.querySelector('.dialogue-text');
                const prevEl = lineDiv.querySelector('.dialogue-var-preview');
                if (!textEl || !prevEl) return;
                const raw = (textEl.innerText || '');
                const hasToken = /\{\{\s*[A-Za-z_]\w*\s*\}\}/.test(raw);
                if (!hasToken) { prevEl.style.display = 'none'; prevEl.textContent = ''; return; }
                const interp = interpolateVariables(raw);
                if (interp === raw) { prevEl.style.display = 'none'; prevEl.textContent = ''; return; }
                prevEl.style.display = 'block';
                prevEl.textContent = '‚ñ∂ ' + interp;
            });
        }

        function closeInlineVarPicker() {
            if (__inlineVarPickerEl) {
                try { __inlineVarPickerEl.remove(); } catch {}
                __inlineVarPickerEl = null;
            }
        }

        function insertTextAtCaret(editableEl, textToInsert) {
            editableEl.focus();
            const sel = window.getSelection();
            if (!sel) { editableEl.innerText += textToInsert; return; }
            if (sel.rangeCount === 0) { editableEl.innerText += textToInsert; return; }

            const range = sel.getRangeAt(0);
            // Ensure insertion happens within the editable element
            const container = range.commonAncestorContainer;
            if (editableEl.contains(container)) {
                range.deleteContents();
                const tn = document.createTextNode(textToInsert);
                range.insertNode(tn);
                // Move caret after inserted text
                range.setStartAfter(tn);
                range.setEndAfter(tn);
                sel.removeAllRanges();
                sel.addRange(range);
            } else {
                editableEl.innerText += textToInsert;
            }
        }

        function openInlineVarPicker(anchorBtn, editableEl) {
            closeInlineVarPicker();

            const vars = (project?.entities?.variables || []).map(v => v?.name).filter(Boolean);
            if (!vars.length) {
                alert('No variables found. Create one in Entities ‚Üí Variables first.');
                return;
            }

            const picker = document.createElement('select');
            picker.className = 'inline-var-picker';
            const opt0 = document.createElement('option');
            opt0.value = '';
            opt0.textContent = 'Insert variable‚Ä¶';
            picker.appendChild(opt0);

            for (const name of vars) {
                const o = document.createElement('option');
                o.value = name;
                o.textContent = name;
                picker.appendChild(o);
            }

            const rect = anchorBtn.getBoundingClientRect();
            picker.style.left = `${Math.min(rect.left, window.innerWidth - 280)}px`;
            picker.style.top = `${Math.min(rect.bottom + 6, window.innerHeight - 120)}px`;

            picker.addEventListener('change', () => {
                const name = picker.value;
                if (!name) return;
                insertTextAtCaret(editableEl, `{{${name}}}`);
                closeInlineVarPicker();
                refreshNodeVariablePreviews();
                markUnsaved();
            });

            // Dismiss on outside click / Escape
            const onDocDown = (e) => {
                if (e.target === picker || picker.contains(e.target)) return;
                closeInlineVarPicker();
                document.removeEventListener('mousedown', onDocDown, true);
            };
            document.addEventListener('mousedown', onDocDown, true);
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') closeInlineVarPicker();
            }, { once: true });

            document.body.appendChild(picker);
            __inlineVarPickerEl = picker;
            picker.focus();
        }

        // --- Connection picker helpers ---
        function ensureConnectionIds() {
            for (const c of connections) {
                if (!c.id) c.id = uid('conn');
            }
        }

        function describeConnection(conn) {
            const fromNode = nodes.find(n => n.id === conn.from.nodeId);
            const toNode = nodes.find(n => n.id === conn.to.nodeId);
            const fromLabel = fromNode ? `#${fromNode.number || ''} ${fromNode.title || fromNode.type || 'Node'}` : conn.from.nodeId;
            const toLabel = toNode ? `#${toNode.number || ''} ${toNode.title || toNode.type || 'Node'}` : conn.to.nodeId;
            return `${fromLabel} (L${Number(conn.from.lineIndex) + 1}) ‚Üí ${toLabel}`;
        }

        function refreshConnectionPicker() {
            const picker = document.getElementById('connPicker');
            if (!picker) return;
            ensureConnectionIds();

            const current = picker.value;
            // Build options
            picker.innerHTML = '';
            const opt0 = document.createElement('option');
            opt0.value = '';
            opt0.textContent = '-- Select connection --';
            picker.appendChild(opt0);

            for (const conn of connections) {
                const opt = document.createElement('option');
                opt.value = conn.id;
                opt.textContent = describeConnection(conn);
                picker.appendChild(opt);
            }

            // Restore selection if possible
            if (selectedConnection?.id) picker.value = selectedConnection.id;
            else if (current) picker.value = current;
        }

        
function setConnectionControlsEnabled(enabled) {
            const ids = ['connCondition','connLogic','addConnConditionBtn','connSetVar','connSetValue'];
            for (const id of ids) {
                const el = document.getElementById(id);
                if (!el) continue;
                el.disabled = !enabled;
                el.style.opacity = enabled ? '1' : '0.65';
            }
            const t = document.getElementById('traverseConnBtn');
            const d = document.getElementById('deleteConnBtn');
            if (t) { t.disabled = !enabled; t.style.opacity = enabled ? '1' : '0.65'; }
            if (d) { d.disabled = !enabled; d.style.opacity = enabled ? '1' : '0.65'; }
        }





        
function setVariableValue(varName, value) {
            const resolved = resolveVariableName(varName) || (String(varName || '').trim() || null);
            if (!resolved) return false;

            const v = project?.entities?.variables?.find(x => x.name === resolved)
                || project?.entities?.variables?.find(x => String(x?.name || '').toLowerCase() === String(resolved).toLowerCase());
            if (!v) return false;

            // Type coercion based on variable type
            if (v.varType === 'number') {
                runtimeVariables[v.name] = parseFloat(value) || 0;
            } else if (v.varType === 'boolean') {
                runtimeVariables[v.name] = (value === 'true' || value === true || value === '1');
            } else {
                runtimeVariables[v.name] = String(value);
            }
            markDrawDirty(); // Redraw to update condition badges
            renderSidebarVariables(); // Keep variable sidebar in sync
            refreshNodeVariablePreviews();
            updateConditionPreview();
            updateNodeActionsUI();
            return true;
        }

        
function normalizeConditionExpression(input) {
            if (!input) return '';
            let s = String(input);

            // Allow {{var}} tokens in conditions
            s = s.replace(/\{\{\s*([A-Za-z_]\w*)\s*\}\}/g, '$1');

            // Friendly arrows
            s = s.replace(/=>/g, '>=');
            s = s.replace(/=<+/g, '<=');

            // Normalize separators
            s = s.replace(/\bAND\b/gi, 'and').replace(/\bOR\b/gi, 'or');

            return s.trim();
        }

        function parseAtomicCondition(str) {
            if (!str) return null;
            const cleaned = String(str).trim();
            const match = cleaned.match(/^(.+?)\s*(>=|<=|==|!=|>|<)\s*(.+)$/);
            if (!match) return null;
            const varName = String(match[1] || '').trim();
            if (!varName) return null;
            return { varName, operator: match[2], rawValue: match[3] };
        }

        function evaluateAtomicCondition(varName, operator, rawValue) {
            const actualValue = getVariableValue(varName);

            if (actualValue === undefined) {
                return { passes: false, reason: `Variable "${varName}" not found`, varName, actualValue, operator, rawValue };
            }

            let targetValue = String(rawValue ?? '').trim();

            // Type coercion based on actual value type
            if (typeof actualValue === 'number') {
                const num = parseFloat(targetValue);
                if (isNaN(num)) {
                    return { passes: false, reason: `Cannot compare number to "${rawValue}"`, varName, actualValue, operator, rawValue };
                }
                targetValue = num;
            } else if (typeof actualValue === 'boolean') {
                targetValue = (targetValue === 'true' || targetValue === '1');
            } else {
                // string: keep as-is (but strip quotes if user wrote them)
                targetValue = targetValue.replace(/^['"]|['"]$/g, '');
            }

            let passes = false;
            switch (operator) {
                case '>=': passes = actualValue >= targetValue; break;
                case '<=': passes = actualValue <= targetValue; break;
                case '>': passes = actualValue > targetValue; break;
                case '<': passes = actualValue < targetValue; break;
                case '==': passes = actualValue == targetValue; break;
                case '!=': passes = actualValue != targetValue; break;
            }

            return { passes, varName, actualValue, operator, targetValue, rawValue };
        }

        function evaluateCondition(conditionStr) {
            if (!conditionStr || !String(conditionStr).trim()) {
                return { passes: true, reason: 'No condition', hasCondition: false, details: [], passedCount: 0, totalCount: 0 };
            }

            const expr = normalizeConditionExpression(conditionStr);
            if (!expr) {
                return { passes: true, reason: 'No condition', hasCondition: false, details: [], passedCount: 0, totalCount: 0 };
            }

            // Split into OR clauses (supports: "or", "||")
            const orClauses = expr.split(/\s*(?:\|\||\bor\b)\s*/i).map(s => s.trim()).filter(Boolean);

            let details = [];
            let clausePasses = [];
            let passedCount = 0;
            let totalCount = 0;

            for (const clause of orClauses) {
                // Split into AND parts (supports: "and", "&&")
                const andParts = clause.split(/\s*(?:&&|\band\b)\s*/i).map(s => s.trim()).filter(Boolean);

                if (!andParts.length) continue;

                let clauseOk = true;

                for (const part of andParts) {
                    const parsed = parseAtomicCondition(part);
                    let res;

                    if (!parsed) {
                        res = { passes: false, reason: 'Invalid syntax: use "variable operator value"', text: part };
                        clauseOk = false;
                        details.push(res);
                        totalCount++;
                        continue;
                    }

                    res = evaluateAtomicCondition(parsed.varName, parsed.operator, parsed.rawValue);
                    res.text = `${parsed.varName} ${parsed.operator} ${String(parsed.rawValue).trim()}`;

                    details.push(res);
                    totalCount++;
                    if (res.passes) passedCount++;
                    clauseOk = clauseOk && !!res.passes;
                }

                clausePasses.push(clauseOk);
            }

            if (!details.length) {
                return { passes: true, reason: 'No condition', hasCondition: false, details: [], passedCount: 0, totalCount: 0 };
            }

            const overallPass = (orClauses.length > 1) ? clausePasses.some(Boolean) : clausePasses[0];

            const firstFail = details.find(d => !d.passes);
            const reason = overallPass ? 'All required conditions pass' : (firstFail?.reason || (firstFail?.text ? `Failed: ${firstFail.text}` : 'Condition failed'));

            return { passes: overallPass, reason, hasCondition: true, details, passedCount, totalCount };
        }


        function executeConnectionAction(conn) {
            // Execute "set variable" action on connection traverse
            if (conn.setVar && conn.setValue !== undefined && conn.setValue !== '') {
                setVariableValue(conn.setVar, conn.setValue);
            }
        }


        function ensureNodeEnterActions(node) {
            if (!node) return;
            if (!Array.isArray(node.onEnterActions)) node.onEnterActions = [];
        }

        function applyNodeEnterAction(action) {
            if (!action) return;
            const name = resolveVariableName(action.varName || action.var || action.name);
            if (!name) return;

            const vDef = project?.entities?.variables?.find(x => x.name === name);
            const type = vDef?.varType || (typeof getVariableValue(name));

            const mode = (action.mode || action.op || 'set');

            if (mode === 'toggle') {
                const cur = !!getVariableValue(name);
                setVariableValue(name, (!cur));
                return;
            }

            if (mode === 'add' || mode === 'sub') {
                const cur = Number(getVariableValue(name) || 0);
                const delta = Number(action.value ?? 0);
                const next = mode === 'add' ? (cur + delta) : (cur - delta);
                setVariableValue(name, next);
                return;
            }

            // default: set
            setVariableValue(name, action.value ?? '');
        }

        function executeNodeEnterActions(node) {
            if (!node) return;
            ensureNodeEnterActions(node);
            for (const a of node.onEnterActions) {
                applyNodeEnterAction(a);
            }
        }

        function buildNodeActionRow(action, index) {
            const row = document.createElement('div');
            row.className = 'node-action-row';
            row.style.display = 'flex';
            row.style.gap = '6px';
            row.style.alignItems = 'center';

            const varSel = document.createElement('select');
            varSel.style.flex = '1';
            varSel.style.padding = '6px';
            varSel.style.borderRadius = '6px';
            varSel.style.border = '1px solid var(--border-secondary)';
            varSel.style.background = 'var(--input-bg)';
            varSel.style.color = 'var(--text-primary)';
            varSel.style.fontSize = '12px';

            const opt0 = document.createElement('option');
            opt0.value = '';
            opt0.textContent = '-- Variable --';
            varSel.appendChild(opt0);

            const vars = (project?.entities?.variables || []).map(v => v?.name).filter(Boolean);
            for (const name of vars) {
                const o = document.createElement('option');
                o.value = name;
                o.textContent = name;
                varSel.appendChild(o);
            }

            const modeSel = document.createElement('select');
            modeSel.style.width = '78px';
            modeSel.style.padding = '6px';
            modeSel.style.borderRadius = '6px';
            modeSel.style.border = '1px solid var(--border-secondary)';
            modeSel.style.background = 'var(--input-bg)';
            modeSel.style.color = 'var(--text-primary)';
            modeSel.style.fontSize = '12px';

            const modes = [
                { v: 'set', t: '=' },
                { v: 'add', t: '+=' },
                { v: 'sub', t: '-=' },
                { v: 'toggle', t: 'toggle' }
            ];
            for (const mm of modes) {
                const o = document.createElement('option');
                o.value = mm.v;
                o.textContent = mm.t;
                modeSel.appendChild(o);
            }

            const valInput = document.createElement('input');
            valInput.type = 'text';
            valInput.placeholder = 'value';
            valInput.style.width = '84px';
            valInput.style.padding = '6px';
            valInput.style.borderRadius = '6px';
            valInput.style.border = '1px solid var(--border-secondary)';
            valInput.style.background = 'var(--input-bg)';
            valInput.style.color = 'var(--text-primary)';
            valInput.style.fontSize = '12px';

            const rmBtn = document.createElement('button');
            rmBtn.textContent = '√ó';
            rmBtn.className = 'danger';
            rmBtn.title = 'Remove action';
            rmBtn.style.width = '34px';

            varSel.value = action?.varName || action?.var || '';
            modeSel.value = action?.mode || action?.op || 'set';
            valInput.value = (action?.value ?? '');

            const sync = () => {
                if (!selectedNode) return;
                ensureNodeEnterActions(selectedNode);
                const list = selectedNode.onEnterActions;
                const a = list[index] || {};
                a.varName = varSel.value;
                a.mode = modeSel.value;
                a.value = valInput.value;
                list[index] = a;
                markUnsaved();
            };

            varSel.addEventListener('change', sync);
            modeSel.addEventListener('change', () => {
                // Toggle doesn't need a value
                valInput.disabled = (modeSel.value === 'toggle');
                valInput.style.opacity = valInput.disabled ? '0.7' : '1';
                sync();
            });
            valInput.addEventListener('input', debounce(sync, 120));

            rmBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!selectedNode) return;
                ensureNodeEnterActions(selectedNode);
                selectedNode.onEnterActions.splice(index, 1);
                updateNodeActionsUI();
                markUnsaved();
            });

            // Initial toggle state
            valInput.disabled = (modeSel.value === 'toggle');
            valInput.style.opacity = valInput.disabled ? '0.7' : '1';

            row.appendChild(varSel);
            row.appendChild(modeSel);
            row.appendChild(valInput);
            row.appendChild(rmBtn);
            return row;
        }

        function updateNodeActionsUI() {
            const listEl = document.getElementById('nodeActionsList');
            const addBtn = document.getElementById('addNodeActionBtn');
            const simBtn = document.getElementById('simulateEnterNodeBtn');
            if (!listEl) return;

            const enabled = !!selectedNode;

            if (addBtn) {
                addBtn.disabled = !enabled;
                addBtn.style.opacity = enabled ? '1' : '0.65';
            }
            if (simBtn) {
                simBtn.disabled = !enabled;
                simBtn.style.opacity = enabled ? '1' : '0.65';
            }

            listEl.innerHTML = '';

            if (!enabled) {
                const hint = document.createElement('div');
                hint.style.fontSize = '11px';
                hint.style.color = 'var(--text-secondary)';
                hint.textContent = 'Select a node to add actions.';
                listEl.appendChild(hint);
                return;
            }

            ensureNodeEnterActions(selectedNode);

            const actions = selectedNode.onEnterActions;
            if (!actions.length) {
                // show one empty row to invite editing
                actions.push({ varName: '', mode: 'set', value: '' });
            }

            actions.forEach((a, i) => {
                listEl.appendChild(buildNodeActionRow(a, i));
            });
        }


        let undoStack = [];
        let redoStack = [];
        let isRestoringHistory = false;

        function isEditableElement(el) {
            if (!el) return false;
            if (el.isContentEditable) return true;
            const tag = (el.tagName || '').toUpperCase();
            return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
        }

        function getHistoryStateObject() {
            return {
                nodes: nodes.map(n => ({
                    id: n.id,
                    number: n.number,
                    title: n.title,
                    lines: n.lines,
                    position: { x: n.x, y: n.y },
                    color: n.color,
                    type: n.type,
                    attach_to: n.attach_to,
                    attach_side: n.attach_side,
                    attach_order: n.attach_order
                })),
                connections: connections.map(c => ({
                    from_node: c.from.nodeId,
                    from_line: c.from.lineIndex,
                    to_node: c.to.nodeId,
                    condition: c.condition || '',
                    setVar: c.setVar || '',
                    setValue: c.setValue || ''
                })),
                metadata: {
                    version: '3.2',
                    nodeCounter: nodeIdCounter,
                    attachOrderCounter
                }
            };
        }

        function serializeHistoryState() {
            return JSON.stringify(getHistoryStateObject());
        }

        function initHistory() {
            undoStack = [serializeHistoryState()];
            redoStack = [];
        }

        function commitHistory() {
            if (isRestoringHistory) return;
            const snap = serializeHistoryState();
            if (undoStack.length === 0 || undoStack[undoStack.length - 1] !== snap) {
                undoStack.push(snap);
                if (undoStack.length > 200) undoStack.shift();
            }
            redoStack = [];
        }

        function restoreHistorySnapshot(snapshotStr) {
            isRestoringHistory = true;
            try {
                const data = JSON.parse(snapshotStr);
                loadDataObject(data);
            } finally {
                isRestoringHistory = false;
            }
            hasUnsavedChanges = true;
            updateSaveIndicator();
            markDrawDirty();
        }

        function undo() {
            if (undoStack.length <= 1) return;
            const current = undoStack.pop();
            redoStack.push(current);
            const prev = undoStack[undoStack.length - 1];
            restoreHistorySnapshot(prev);
        }

        function redo() {
            if (!redoStack.length) return;
            const next = redoStack.pop();
            undoStack.push(next);
            restoreHistorySnapshot(next);
        }

        const view = {
            panX: 0,
            panY: 0,
            zoom: 1,
            targetPanX: 0,
            targetPanY: 0,
            targetZoom: 1,
            isZooming: false,
            zoomAnchor: null
        };
        const viewport = { width: 0, height: 0 };

        let viewDirty = true;
        let drawDirty = true;
        let rafPending = false;
        let snapDirty = true;
        let snapsActive = false;

        function requestFrame() {
            if (rafPending) return;
            rafPending = true;
            requestAnimationFrame(() => {
                rafPending = false;
                if (viewDirty) {
                    viewDirty = false;
                    applyViewTransform();
                    drawDirty = true;
                }
                if (drawDirty) {
                    drawDirty = false;
                    drawConnections();
                }
                maybeSnapNodesToPixels();
                if (viewDirty || drawDirty) requestFrame();
            });
        }

        function markViewDirty() {
            viewDirty = true;
            drawDirty = true;
            snapDirty = true;
            requestFrame();
        }

        function markDrawDirty() {
            drawDirty = true;
            snapDirty = true;
            requestFrame();
        }

        function clampZoom(z) {
            return Math.max(0.35, Math.min(2.5, z));
        }

        function cancelViewAnimation() {
            view.isZooming = false;
            view.targetPanX = view.panX;
            view.targetPanY = view.panY;
            view.targetZoom = view.zoom;
            view.zoomAnchor = null;
        }

        function setViewImmediate(panX, panY, zoom) {
            view.panX = panX;
            view.panY = panY;
            view.zoom = clampZoom(zoom);
            cancelViewAnimation();
        }

        function applyViewTransform() {
            if (view.isZooming) {
                const ease = 0.18;
                const dz = view.targetZoom - view.zoom;

                view.zoom += dz * ease;

                if (view.zoomAnchor) {
                    const ax = view.zoomAnchor.screenX;
                    const ay = view.zoomAnchor.screenY;
                    view.panX = ax - view.zoomAnchor.worldX * view.zoom;
                    view.panY = ay - view.zoomAnchor.worldY * view.zoom;
                } else {
                    const dx = view.targetPanX - view.panX;
                    const dy = view.targetPanY - view.panY;
                    view.panX += dx * ease;
                    view.panY += dy * ease;
                }

                if (Math.abs(dz) < 0.0005) {
                    view.zoom = view.targetZoom;
                    if (view.zoomAnchor) {
                        view.panX = view.zoomAnchor.screenX - view.zoomAnchor.worldX * view.zoom;
                        view.panY = view.zoomAnchor.screenY - view.zoomAnchor.worldY * view.zoom;
                    } else {
                        view.panX = view.targetPanX;
                        view.panY = view.targetPanY;
                    }
                    view.isZooming = false;
                    view.zoomAnchor = null;
                } else {
                    viewDirty = true;
                }
            }

            const panX = view.panX;
            const panY = view.panY;
            const zoom = view.zoom;
            world.style.transform = `translate3d(${panX}px, ${panY}px, 0)`;
            if (supportsCssZoom && useCssZoom) {
                nodesContainer.style.zoom = String(zoom);
                nodesContainer.style.transform = '';
                nodesContainer.classList.remove('zooming');
            } else {
                nodesContainer.style.zoom = '';
                nodesContainer.style.transform = `scale(${zoom})`;
                nodesContainer.classList.remove('zooming');
            }
            const zoomText = document.getElementById('zoomText');
            if (zoomText) zoomText.textContent = Math.round(view.zoom * 100) + '%';
        }

        function screenToWorld(clientX, clientY, rectOverride) {
            const rect = rectOverride || canvasContainer.getBoundingClientRect();
            const mx = clientX - rect.left;
            const my = clientY - rect.top;
            return {
                x: (mx - view.panX) / view.zoom,
                y: (my - view.panY) / view.zoom
            };
        }

        function zoomAt(clientX, clientY, newZoom, smooth = true) {
            newZoom = clampZoom(newZoom);
            const rect = canvasContainer.getBoundingClientRect();
            const mx = clientX - rect.left;
            const my = clientY - rect.top;

            const baseZoom = view.isZooming ? view.targetZoom : view.zoom;
            const basePanX = view.isZooming ? view.targetPanX : view.panX;
            const basePanY = view.isZooming ? view.targetPanY : view.panY;

            const wx = (mx - basePanX) / baseZoom;
            const wy = (my - basePanY) / baseZoom;

            const nextPanX = mx - wx * newZoom;
            const nextPanY = my - wy * newZoom;

            if (smooth) {
                view.targetZoom = newZoom;
                view.targetPanX = nextPanX;
                view.targetPanY = nextPanY;
                view.zoomAnchor = { screenX: mx, screenY: my, worldX: wx, worldY: wy };
                view.isZooming = true;
            } else {
                setViewImmediate(nextPanX, nextPanY, newZoom);
            }

            markViewDirty();
        }

        function zoomIn() {
            const rect = canvasContainer.getBoundingClientRect();
            const baseZoom = view.isZooming ? view.targetZoom : view.zoom;
            zoomAt(rect.left + rect.width / 2, rect.top + rect.height / 2, baseZoom * 1.15);
        }

        function zoomOut() {
            const rect = canvasContainer.getBoundingClientRect();
            const baseZoom = view.isZooming ? view.targetZoom : view.zoom;
            zoomAt(rect.left + rect.width / 2, rect.top + rect.height / 2, baseZoom / 1.15);
        }

        function resetView() {
            setViewImmediate(0, 0, 1);
            markViewDirty();
        }




        function fitView() {
            if (!nodes.length) {
                resetView();
                return;
            }

            // If a node is selected, fit that node; otherwise fit all nodes.
            const targets = selectedNode ? [selectedNode] : nodes;

            const pad = 60; // screen pixels
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            for (const n of targets) {
                const el = n.element;
                const w = el ? el.offsetWidth : 300;
                const h = el ? el.offsetHeight : 160;
                minX = Math.min(minX, n.x);
                minY = Math.min(minY, n.y);
                maxX = Math.max(maxX, n.x + w);
                maxY = Math.max(maxY, n.y + h);
            }

            const bboxW = Math.max(1, maxX - minX);
            const bboxH = Math.max(1, maxY - minY);

            const vw = viewport.width || canvasContainer.clientWidth || window.innerWidth;
            const vh = viewport.height || canvasContainer.clientHeight || window.innerHeight;

            const zoomX = (vw - pad * 2) / bboxW;
            const zoomY = (vh - pad * 2) / bboxH;

            const nextZoom = clampZoom(Math.min(zoomX, zoomY));

            const cx = minX + bboxW / 2;
            const cy = minY + bboxH / 2;

            const nextPanX = vw / 2 - cx * nextZoom;
            const nextPanY = vh / 2 - cy * nextZoom;
            setViewImmediate(nextPanX, nextPanY, nextZoom);

            markViewDirty();
        }

        // Theme management
        function initTheme() {
            const savedTheme = localStorage.getItem('narrativeFlowTheme') || 'dark';
            setTheme(savedTheme);
        }

        function setTheme(theme) {
            currentTheme = theme;
            document.documentElement.setAttribute('data-theme', theme);
            const themeText = document.getElementById('themeText');
            if (themeText) {
                const nextLabel = theme === 'dark' ? 'Light' : 'Dark';
                themeText.textContent = nextLabel;
                const themeBtn = themeText.closest('button');
                if (themeBtn) themeBtn.title = `Switch to ${nextLabel} mode`;
            }
            localStorage.setItem('narrativeFlowTheme', theme);
            markDrawDirty();
        }

        function toggleTheme() {
            setTheme(currentTheme === 'dark' ? 'light' : 'dark');
        }

        // Canvas sizing (viewport only, fast)
        function resizeCanvas() {
            const rect = canvasContainer.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;

            viewport.width = Math.max(1, Math.floor(rect.width));
            viewport.height = Math.max(1, Math.floor(rect.height));

            canvas.width = Math.floor(viewport.width * dpr);
            canvas.height = Math.floor(viewport.height * dpr);
            canvas.style.width = viewport.width + 'px';
            canvas.style.height = viewport.height + 'px';

            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            markDrawDirty();
        }

        // Node class
        class Node {
            constructor(id, number, title, lines, x, y, color = 'blue', type = 'normal', attach_to = null, attach_side = 'bottom', attach_order = 0) {
                this.id = id;
                this.number = number;
                this.title = title;
                this.lines = lines;
                this.x = x;
                this.y = y;
                this.color = color;
                this.type = type;
                this.attach_to = attach_to;
                this.attach_side = attach_side;
                this.attach_order = attach_order;
                this.element = null;
                this.render();
            }

            render() {
                const node = document.createElement('div');
                node.className = 'node';
                node.style.left = this.x + 'px';
                node.style.top = this.y + 'px';
                node.dataset.nodeId = this.id;
                const header = document.createElement('div');
                header.className = 'node-header ' + this.color;
                header.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return;
                    if (e.target.closest('input') || e.target.closest('button')) return;
                    selectNode(this);
                    e.stopPropagation();
                    startDrag(e, this);
                });

                const numberSpan = document.createElement('span');
                numberSpan.className = 'node-number';
                numberSpan.textContent = '#' + this.number;

                const titleSpan = document.createElement('div');
                titleSpan.className = 'node-title';
                titleSpan.textContent = this.title;
                titleSpan.ondblclick = (e) => {
                    e.stopPropagation();
                    this.editTitle(header, titleSpan);
                };

                const typeBadge = document.createElement('span');
                typeBadge.className = 'node-type-badge';
                typeBadge.textContent = this.type;

                header.appendChild(numberSpan);
                header.appendChild(titleSpan);
                header.appendChild(typeBadge);

                const content = document.createElement('div');
                content.className = 'node-content';

                const inputPoint = document.createElement('div');
                inputPoint.className = 'node-input-point';
                inputPoint.dataset.nodeId = this.id;
                inputPoint.dataset.type = 'input';
                node.appendChild(inputPoint);

                this.renderLines(content);

                node.appendChild(header);
                node.appendChild(content);
                nodesContainer.appendChild(node);

                this.element = node;
            }

            renderLines(content) {
                content.innerHTML = '';

                this.lines.forEach((line, index) => {
                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'dialogue-line';
                    lineDiv.dataset.nodeId = this.id;
                    lineDiv.dataset.lineIndex = index;

                    if (this.type === 'character') {
                        const speakerRow = document.createElement('div');
                        speakerRow.className = 'line-speaker-row';

                        const speakerSpan = document.createElement('span');
                        speakerSpan.className = 'line-speaker';
                        speakerSpan.dataset.speakerId = line.speakerId || '';
                        const resolvedSpeaker = (line.speakerId && project && project.entities && Array.isArray(project.entities.characters))
                            ? (project.entities.characters.find(c => c.id === line.speakerId)?.name)
                            : null;
                        speakerSpan.textContent = resolvedSpeaker || line.speaker || 'Character';
                        speakerSpan.dataset.speakerId = line.speakerId || '';
                        speakerSpan.onclick = (e) => {
                            e.stopPropagation();
                            // Click = pick from Characters; Ctrl/‚åò-click = free text
                            if (e.ctrlKey || e.metaKey) {
                                this.editSpeaker(speakerRow, speakerSpan, index);
                            } else {
                                this.openSpeakerPicker(speakerRow, speakerSpan, index);
                            }
                        };

                        speakerRow.appendChild(speakerSpan);
                        lineDiv.appendChild(speakerRow);
                    }


                    const textSpan = document.createElement('div');
                    textSpan.className = 'dialogue-text';
                    textSpan.contentEditable = 'true';
                    textSpan.spellcheck = false;
                    textSpan.dataset.placeholder = 'Dialogue...';
                    textSpan.innerText = (line.text ?? '');

                    // If the line is still the default placeholder text, clear it on first click/focus.
                    textSpan.addEventListener('focus', () => {
                        if (textSpan.dataset.clearedOnce === '1') return;
                        const raw = (textSpan.innerText || '').trim();
                        if (raw === 'Text line') {
                            textSpan.dataset.clearedOnce = '1';
                            textSpan.innerText = '';
                            this.lines[index].text = '';
                            refreshVarPreview();
                            markUnsaved();
                            scheduleLayout();
                        }
                    });


                    // Immediate editing on click; no auto-select to avoid accidental overwrites.
                    textSpan.addEventListener('input', () => {
                        this.lines[index].text = (textSpan.innerText || '');
                        refreshVarPreview();
                        markUnsaved();
                        scheduleLayout();
                    });

                    textSpan.addEventListener('blur', () => {
                        this.lines[index].text = (textSpan.innerText || '');
                        refreshVarPreview();
                        commitHistory();
                    });

                    const varPreview = document.createElement('div');
                    varPreview.className = 'dialogue-var-preview';

                    const refreshVarPreview = () => {
                        const raw = (textSpan.innerText || '');
                        const hasToken = /\{\{\s*[A-Za-z_]\w*\s*\}\}/.test(raw);
                        if (!hasToken) { varPreview.style.display = 'none'; varPreview.textContent = ''; return; }
                        const interp = interpolateVariables(raw);
                        if (interp === raw) { varPreview.style.display = 'none'; varPreview.textContent = ''; return; }
                        varPreview.style.display = 'block';
                        varPreview.textContent = '‚ñ∂ ' + interp;
                    };

                    refreshVarPreview();

                    const controlsRow = document.createElement('div');
                    controlsRow.className = 'line-controls';

                    const varBtn = document.createElement('button');
                    varBtn.className = 'line-var-btn';
                    varBtn.textContent = '{}';
                    varBtn.title = 'Insert variable (uses {{varName}} tokens)';
                    varBtn.onclick = (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        openInlineVarPicker(varBtn, textSpan);
                    };

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'line-delete-btn';
                    deleteBtn.textContent = '√ó';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.deleteLine(index);
                    };

                    const connectionPoint = document.createElement('div');
                    connectionPoint.className = 'connection-point';
                    connectionPoint.dataset.nodeId = this.id;
                    connectionPoint.dataset.lineIndex = index;
                    connectionPoint.dataset.type = 'output';

                    controlsRow.appendChild(varBtn);
                    controlsRow.appendChild(deleteBtn);

                    lineDiv.appendChild(textSpan);
                    lineDiv.appendChild(varPreview);
                    lineDiv.appendChild(controlsRow);
                    lineDiv.appendChild(connectionPoint);
                    content.appendChild(lineDiv);
                });

                const addLineBtn = document.createElement('div');
                addLineBtn.className = 'add-line-btn';
                addLineBtn.textContent = '+ Add Line';
                addLineBtn.onclick = (e) => {
                    e.stopPropagation();
                    this.addLine();
                };
                content.appendChild(addLineBtn);
            }

            editTitle(header, titleElement) {
                // Remove any existing title input
                const existing = header.querySelector('.node-title-input');
                if (existing) existing.remove();

                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'node-title-input';
                input.value = this.title;

                input.onblur = () => {
                    this.title = input.value || 'Untitled';
                    titleElement.textContent = this.title;
                    titleElement.style.display = 'block';
                    input.remove();
                    markUnsaved();
                    scheduleLayout();
                    commitHistory();
                };

                input.onkeydown = (e) => {
                    if (e.key === 'Enter') input.blur();
                    e.stopPropagation();
                };

                titleElement.style.display = 'none';
                header.insertBefore(input, header.querySelector('.node-type-badge'));
                input.focus();
                input.select();
            }


            openSpeakerPicker(speakerRow, speakerSpan, index) {
                const chars = (project && project.entities && Array.isArray(project.entities.characters))
                    ? project.entities.characters
                    : [];

                // If no characters exist yet, fall back to free text edit.
                if (!chars.length) {
                    this.editSpeaker(speakerRow, speakerSpan, index);
                    return;
                }

                // Build select
                const sel = document.createElement('select');
                sel.className = 'speaker-select';

                const optPlaceholder = document.createElement('option');
                optPlaceholder.value = '';
                optPlaceholder.textContent = 'Select character‚Ä¶';
                sel.appendChild(optPlaceholder);

                for (const c of chars) {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = c.name || 'Unnamed';
                    sel.appendChild(opt);
                }

                const optCustom = document.createElement('option');
                optCustom.value = '__custom__';
                optCustom.textContent = 'Custom‚Ä¶';
                sel.appendChild(optCustom);

                // Preselect (by stored speakerId first, then by speaker name)
                const cur = this.lines[index] || {};
                if (cur.speakerId && chars.some(c => c.id === cur.speakerId)) {
                    sel.value = cur.speakerId;
                } else if (cur.speaker) {
                    const byName = chars.find(c => c.name === cur.speaker);
                    if (byName) sel.value = byName.id;
                }

                const cleanup = () => {
                    speakerSpan.style.display = 'inline';
                    sel.remove();
                };

                const commit = () => {
                    const val = sel.value;

                    if (val === '__custom__') {
                        cleanup();
                        this.editSpeaker(speakerRow, speakerSpan, index);
                        return;
                    }

                    if (val) {
                        const chosen = chars.find(c => c.id === val);
                        this.lines[index].speakerId = val;
                        this.lines[index].speaker = chosen?.name || 'Character';
                    } else {
                        // Keep existing text if placeholder selected
                        this.lines[index].speakerId = '';
                        this.lines[index].speaker = this.lines[index].speaker || 'Character';
                    }

                    speakerSpan.textContent = this.lines[index].speaker || 'Character';
                    speakerSpan.dataset.speakerId = this.lines[index].speakerId || '';
                    cleanup();
                    markUnsaved();
                    scheduleLayout();
                    commitHistory();
                };

                sel.onchange = (e) => {
                    e.stopPropagation();
                    commit();
                };

                sel.onblur = () => {
                    if (document.body.contains(sel)) commit();
                };

                sel.onkeydown = (e) => {
                    if (e.key === 'Escape') {
                        // Cancel
                        cleanup();
                        e.stopPropagation();
                        return;
                    }
                    if (e.key === 'Enter') {
                        commit();
                        e.stopPropagation();
                        return;
                    }
                    e.stopPropagation();
                };

                speakerSpan.style.display = 'none';
                speakerRow.insertBefore(sel, speakerSpan);
                sel.focus();
            }

            editSpeaker(speakerRow, speakerSpan, index) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'speaker-input';
                input.value = this.lines[index].speaker || '';

                input.onblur = () => {
                    this.lines[index].speakerId = '';
                    this.lines[index].speaker = input.value || 'Character';
                    speakerSpan.textContent = this.lines[index].speaker;
                    speakerSpan.dataset.speakerId = '';
                    speakerSpan.style.display = 'inline';
                    input.remove();
                    markUnsaved();
                    scheduleLayout();
                    commitHistory();
                };

                input.onkeydown = (e) => {
                    if (e.key === 'Enter') input.blur();
                    e.stopPropagation();
                };

                speakerSpan.style.display = 'none';
                speakerRow.insertBefore(input, speakerSpan);
                input.focus();
                input.select();
            }

            addLine() {
                const newLine = this.type === 'character'
                    ? { speaker: 'Character', text: 'New dialogue line' }
                    : { text: 'New line' };

                this.lines.push(newLine);
                const content = this.element.querySelector('.node-content');
                this.renderLines(content);
                scheduleLayout();
                updateConnectionVisuals();
                markDrawDirty();
                markUnsaved(); commitHistory();
            }

            deleteLine(index) {
                if (this.lines.length <= 1) {
                    alert('Node must have at least one line!');
                    return;
                }
                const ok = confirm('Delete this line and its connections?');
                if (!ok) return;

                connections = connections.filter(conn =>
                    !(conn.from.nodeId === this.id && conn.from.lineIndex === index)
                );

                connections.forEach(conn => {
                    if (conn.from.nodeId === this.id && conn.from.lineIndex > index) {
                        conn.from.lineIndex--;
                    }
                });

                this.lines.splice(index, 1);
                const content = this.element.querySelector('.node-content');
                this.renderLines(content);
                scheduleLayout();
                updateConnectionVisuals();
                markDrawDirty();
                markUnsaved(); commitHistory();
            }

            updatePosition(x, y) {
                this.x = x;
                this.y = y;
                this.element.style.left = x + 'px';
                this.element.style.top = y + 'px';
            }

            changeColor(color) {
                this.color = color;
                const header = this.element.querySelector('.node-header');
                header.className = 'node-header ' + color;
                markUnsaved();
                markDrawDirty(); commitHistory();
            }

            changeType(type) {
                this.type = type;
                const badge = this.element.querySelector('.node-type-badge');
                badge.textContent = type;

                const content = this.element.querySelector('.node-content');
                this.renderLines(content);
                scheduleLayout();
                updateConnectionVisuals();
                markUnsaved();
                markDrawDirty(); commitHistory();
            }

            getOutputPointCenter(lineIndex, containerRect) {
                const points = this.element.querySelectorAll('.connection-point');
                const point = points[lineIndex];
                if (!point) return null;
                const r = point.getBoundingClientRect();
                return {
                    x: r.left + r.width / 2 - containerRect.left,
                    y: r.top + r.height / 2 - containerRect.top
                };
            }

            getInputPointCenter(containerRect) {
                const point = this.element.querySelector('.node-input-point');
                if (!point) return null;
                const r = point.getBoundingClientRect();
                return {
                    x: r.left + r.width / 2 - containerRect.left,
                    y: r.top + r.height / 2 - containerRect.top
                };
            }
        }


        // ---------------- Docking / attachment (stacking) ----------------
        const STACK_GAP = 0;   // world units (unscaled px)
        const DOCK_OVERLAP = 0; // no overlap; seams handled by CSS join classes // px overlap to avoid seams when docked
        const SNAP_X = 36;      // snap tolerance X
        const SNAP_Y = 30;      // snap tolerance Y

        function getNode(id) {
            return nodes.find(n => n.id === id) || null;
        }

        function debounce(fn, ms) {
            let t = null;
            return (...args) => {
                if (t) clearTimeout(t);
                t = setTimeout(() => fn(...args), ms);
            };
        }

        function childrenMap() {
            const m = new Map();
            for (const n of nodes) {
                if (!n.attach_to) continue;
                if (!m.has(n.attach_to)) m.set(n.attach_to, []);
                m.get(n.attach_to).push(n);
            }
            return m;
        }

        function descendantsOf(rootId) {
            const cmap = childrenMap();
            const out = [];
            const stack = (cmap.get(rootId) || []).map(n => n.id);
            while (stack.length) {
                const id = stack.pop();
                out.push(id);
                const kids = cmap.get(id);
                if (kids && kids.length) stack.push(...kids.map(n => n.id));
            }
            return out;
        }

        function wouldCycle(parentId, childId) {
            if (parentId === childId) return true;
            let cur = parentId;
            while (cur) {
                if (cur === childId) return true;
                const n = getNode(cur);
                cur = (n && n.attach_to) ? n.attach_to : null;
            }
            return false;
        }

        function nodeHeight(id) {
            const el = getNode(id)?.element;
            return (el && el.offsetHeight) ? el.offsetHeight : 180;
        }

        function refreshAttachmentClasses() {
            const cmap = childrenMap();
            for (const n of nodes) {
                const el = n.element;
                if (!el) continue;

                const kids = cmap.get(n.id) || [];
                const hasTopKids = kids.some(k => k.attach_side === 'top');
                const hasBottomKids = kids.some(k => (k.attach_side || 'bottom') !== 'top');

                el.classList.toggle('attached', !!n.attach_to);
                el.classList.toggle('attached-top', !!n.attach_to && n.attach_side === 'top');
                el.classList.toggle('attached-bottom', !!n.attach_to && n.attach_side !== 'top');

                el.classList.toggle('stack-parent', kids.length > 0);
                el.classList.toggle('has-top-children', hasTopKids);
                el.classList.toggle('has-bottom-children', hasBottomKids);

                const joinsTop = ((!!n.attach_to) && (n.attach_side !== 'top')) || hasTopKids;
                const joinsBottom = ((!!n.attach_to) && (n.attach_side === 'top')) || hasBottomKids;
                el.classList.toggle('dock-join-top', joinsTop);
                el.classList.toggle('dock-join-bottom', joinsBottom);
            }
        }

        function applyAttachments() {
            // Iterate a few times so deep stacks settle even if parents move this pass.
            for (let pass = 0; pass < 6; pass++) {
                let changed = false;
                const cmap = childrenMap();

                for (const parent of nodes) {
                    const kids = cmap.get(parent.id);
                    if (!kids || !kids.length) continue;

                    const sortFn = (a, b) =>
                        ((a.attach_order || 0) - (b.attach_order || 0)) ||
                        ((a.y || 0) - (b.y || 0)) ||
                        ((a.number || 0) - (b.number || 0));

                    const bottomKids = kids.filter(k => (k.attach_side || 'bottom') !== 'top').sort(sortFn);
                    const topKids = kids.filter(k => k.attach_side === 'top').sort(sortFn);

                    // Bottom stack (downwards)
                    let y = parent.y + nodeHeight(parent.id) + STACK_GAP - DOCK_OVERLAP;
                    for (const child of bottomKids) {
                        const tx = Math.round(parent.x);
                        const ty = Math.round(y);
                        if (child.x !== tx || child.y !== ty) {
                            child.x = tx; child.y = ty;
                            if (child.element) { child.element.style.left = tx + 'px'; child.element.style.top = ty + 'px'; }
                            changed = true;
                        }
                        y += nodeHeight(child.id) + STACK_GAP - DOCK_OVERLAP;
                    }

                    // Top stack (upwards)
                    let yTop = parent.y - STACK_GAP + DOCK_OVERLAP;
                    for (const child of topKids) {
                        const h = nodeHeight(child.id);
                        const tx = Math.round(parent.x);
                        const ty = Math.round(yTop - h);
                        if (child.x !== tx || child.y !== ty) {
                            child.x = tx; child.y = ty;
                            if (child.element) { child.element.style.left = tx + 'px'; child.element.style.top = ty + 'px'; }
                            changed = true;
                        }
                        yTop = ty - STACK_GAP + DOCK_OVERLAP;
                    }
                }

                if (!changed) break;
            }

            refreshAttachmentClasses();
            markDrawDirty();
        }

        const scheduleLayout = debounce(() => {
            applyAttachments();
        }, 60);

        function selectNode(node) {
            document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
            if (node) {
                node.element.classList.add('selected');
                selectedNode = node;
                updateNodeTypeButtons();
                updateNodeActionsUI();
            } else {
                selectedNode = null;
                clearNodeTypeButtons();
                updateNodeActionsUI();
            }
        }

        function updateNodeTypeButtons() {
            document.querySelectorAll('.node-type-btn').forEach(btn => btn.classList.remove('active'));
            if (!selectedNode) return;

            const btn = Array.from(document.querySelectorAll('.node-type-btn'))
                .find(b => b.textContent.toLowerCase() === selectedNode.type);
            if (btn) btn.classList.add('active');
        }

        function clearNodeTypeButtons() {
            document.querySelectorAll('.node-type-btn').forEach(btn => btn.classList.remove('active'));
        }

        function nextNodeIdentity() {
            const n = nodeIdCounter++;
            return { id: 'node_' + n, number: n + 1 };
        }

        function addNewNodeAt(x, y) {
            const ident = nextNodeIdentity();
            const newNode = new Node(
                ident.id,
                ident.number,
                'New Node',
                [{ text: 'Text line' }],
                x, y,
                'blue',
                'normal'
            );

            nodes.push(newNode);
            selectNode(newNode);
            markUnsaved();
            scheduleLayout();
            markDrawDirty(); commitHistory();
        }

        function deleteSelectedNode() {
            if (!selectedNode) {
                alert('Please select a node first!');
                return;
            }
            const ok = confirm('Delete selected node and its connections?');
            if (!ok) return;

            connections = connections.filter(conn =>
                conn.from.nodeId !== selectedNode.id && conn.to.nodeId !== selectedNode.id
            );

            // Detach children (so deleting a parent doesn't delete the whole stack)
            for (const n of nodes) {
                if (n.attach_to === selectedNode.id) {
                    n.attach_to = null;
                    n.attach_side = 'bottom';
                }
            }

            selectedNode.element.remove();
            nodes = nodes.filter(n => n.id !== selectedNode.id);

            applyAttachments();
            selectedNode = null;
            updateConnectionVisuals();
            clearSelectedEndpoint();
            markUnsaved();
            markDrawDirty(); commitHistory();
        }

        function changeNodeColor(color) {
            if (!selectedNode) {
                alert('Please select a node first!');
                return;
            }
            selectedNode.changeColor(color);
        }

        function changeNodeType(type) {
            if (!selectedNode) {
                alert('Please select a node first!');
                return;
            }
            selectedNode.changeType(type);
            updateNodeTypeButtons();
                updateNodeActionsUI();
        }

        // Connection logic (can start from input or output)
        function clearSelectedEndpoint() {
            document.querySelectorAll('.connection-point.active').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.node-input-point.active').forEach(el => el.classList.remove('active'));
            selectedEndpoint = null;
            selectedConnection = null;
            updateConnectionUI();
            markDrawDirty();
        }

        function setSelectedEndpoint(endpoint, el) {
            clearSelectedEndpoint();
            selectedEndpoint = endpoint;
            el.classList.add('active');
            markDrawDirty();
        }

        function createConnection(fromNodeId, fromLineIndex, toNodeId) {
            // Allow branching: multiple outgoing connections from the same output (line)
            // Prevent exact duplicates (same from line -> same target node)
            const exists = connections.some(conn =>
                conn.from.nodeId === fromNodeId &&
                conn.from.lineIndex === fromLineIndex &&
                conn.to.nodeId === toNodeId
            );
            if (exists) {
                updateConnectionVisuals();
                markDrawDirty();
                return;
            }

            connections.push({
                    id: uid('conn'),
                    from: { nodeId: fromNodeId, lineIndex: fromLineIndex },
                to: { nodeId: toNodeId, lineIndex: null }
            });

            updateConnectionVisuals();
            markUnsaved();
            markDrawDirty();
            commitHistory();
        }

        function handleEndpointClick(endpoint, el) {
            // Clicking same active endpoint cancels selection
            if (selectedEndpoint &&
                selectedEndpoint.type === endpoint.type &&
                selectedEndpoint.nodeId === endpoint.nodeId &&
                (selectedEndpoint.lineIndex ?? null) === (endpoint.lineIndex ?? null)) {
                clearSelectedEndpoint();
                return;
            }

            if (!selectedEndpoint) {
                setSelectedEndpoint(endpoint, el);
                return;
            }

            // We have a selection and a second click
            const a = selectedEndpoint;
            const b = endpoint;

            // Prevent connecting node to itself in a nonsensical way
            if (a.nodeId === b.nodeId && (a.type === 'input' || b.type === 'input')) {
                clearSelectedEndpoint();
                return;
            }

            // Prefer output -> input. If both outputs, connect A(output) -> B(node input).
            // If both inputs, just switch selection.
            let from = null;
            let toNodeId = null;

            if (a.type === 'output' && b.type === 'input') {
                from = a;
                toNodeId = b.nodeId;
            } else if (a.type === 'input' && b.type === 'output') {
                from = b;
                toNodeId = a.nodeId;
            } else if (a.type === 'output' && b.type === 'output') {
                from = a;
                toNodeId = b.nodeId;
            } else if (a.type === 'input' && b.type === 'input') {
                setSelectedEndpoint(b, el);
                return;
            }

            if (from && toNodeId && from.nodeId !== toNodeId) {
                createConnection(from.nodeId, from.lineIndex, toNodeId);
            }

            clearSelectedEndpoint();
        }

        function deleteConnectionFromLine(nodeId, lineIndex) {
            const ok = confirm('Delete this connection?');
            if (!ok) return;
            connections = connections.filter(conn =>
                !(conn.from.nodeId === nodeId && conn.from.lineIndex === lineIndex)
            );
            updateConnectionVisuals();
            markUnsaved();
            markDrawDirty(); commitHistory();
        }

        function clearConnections() {
            if (confirm('Delete all connections?')) {
                connections = [];
                updateConnectionVisuals();
                clearSelectedEndpoint();
                markUnsaved();
                markDrawDirty(); commitHistory();
            }

        }

        // Dragging nodes (supports docking / stacking)
        let drag = null; // { rootId, ids, start: Map(id->{x,y}), startPointer:{x,y}, didMove, detached, snap }
        let lastPointerWorld = { x: 0, y: 0 };
        let snapPreview = null;

        function clearSnapPreview() {
            if (snapPreview) {
                const p = getNode(snapPreview.parentId);
                if (p && p.element) p.element.classList.remove('snap-target');
            }
            for (const n of nodes) {
                if (n.element) n.element.classList.remove('snap-preview');
            }
            snapPreview = null;
        }

        function setSnapPreview(snap, rootId) {
            clearSnapPreview();
            if (!snap) return;
            snapPreview = snap;
            const p = getNode(snap.parentId);
            if (p && p.element) p.element.classList.add('snap-target');
            const r = getNode(rootId);
            if (r && r.element) r.element.classList.add('snap-preview');
        }

        function findSnapParentFor(rootId, pointerWorld) {
            const root = getNode(rootId);
            if (!root) return null;

            const rootH = nodeHeight(rootId);
            let best = null;

            for (const cand of nodes) {
                if (cand.id === rootId) continue;
                if (drag && drag.ids && drag.ids.includes(cand.id)) continue;
                if (wouldCycle(cand.id, rootId)) continue;

                const candH = nodeHeight(cand.id);
                const prefersTop = pointerWorld.y <= (cand.y + candH / 2) || root.y < cand.y;

                const targetX = cand.x;
                const targetY = prefersTop
                    ? (cand.y - STACK_GAP + DOCK_OVERLAP - rootH)
                    : (cand.y + candH + STACK_GAP - DOCK_OVERLAP);

                const dx = Math.abs(root.x - targetX);
                const dy = Math.abs(root.y - targetY);

                if (dx <= SNAP_X && dy <= SNAP_Y) {
                    const score = dx + dy;
                    if (!best || score < best.score) {
                        best = { parentId: cand.id, targetX, targetY, score, attachSide: prefersTop ? 'top' : 'bottom' };
                    }
                }
            }

            return best;
        }

        function snapRootTo(snap, rootId) {
            const root = getNode(rootId);
            if (!root || !snap) return;

            const dx = snap.targetX - root.x;
            const dy = snap.targetY - root.y;

            const group = [rootId, ...descendantsOf(rootId)];
            for (const id of group) {
                const n = getNode(id);
                if (!n) continue;
                n.x += dx;
                n.y += dy;
                if (n.element) {
                    n.element.style.left = n.x + 'px';
                    n.element.style.top = n.y + 'px';
                }
            }

            root.attach_to = snap.parentId;
            root.attach_side = snap.attachSide || 'bottom';
            root.attach_order = ++attachOrderCounter;

            applyAttachments();
            clearSnapPreview();
        }

        function startDrag(e, node) {
            // We treat header mousedown as "maybe drag". Only detach once the mouse actually moves a bit.
            const group = [node.id, ...descendantsOf(node.id)];
            const start = new Map();
            for (const id of group) {
                const nn = getNode(id);
                if (nn) start.set(id, { x: nn.x, y: nn.y });
            }

            const w = screenToWorld(e.clientX, e.clientY);
            lastPointerWorld = { x: w.x, y: w.y };

            drag = {
                rootId: node.id,
                ids: group,
                start,
                startPointer: { x: w.x, y: w.y },
                didMove: false,
                detached: false,
                pendingDetachParent: node.attach_to || null,
                pendingDetachSide: node.attach_side || 'bottom',
                snap: null
            };

            isDragging = true;
            draggedNode = node;
            didMoveNode = false;

            clearSnapPreview();
            e.preventDefault();
        }

        document.addEventListener('mousemove', (e) => {
            const rect = canvasContainer.getBoundingClientRect();
            lastPointerScreen = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            const w = screenToWorld(e.clientX, e.clientY, rect);
            lastPointerWorld = { x: w.x, y: w.y };
            if (selectedEndpoint && !drag && !isPanning) {
                markDrawDirty();
            }

            if (drag) {
                const dx = w.x - drag.startPointer.x;
                const dy = w.y - drag.startPointer.y;

                const movedEnough = Math.hypot(dx, dy) > 3;
                if (movedEnough) drag.didMove = true;

                // Detach only once the user actually starts pulling
                if (movedEnough && drag.pendingDetachParent && !drag.detached) {
                    const root = getNode(drag.rootId);
                    if (root) {
                        root.attach_to = null;
                        root.attach_side = 'bottom';
                    }
                    drag.detached = true;
                    drag.pendingDetachParent = null;
                    scheduleLayout(); // collapse remaining siblings while you pull away
                }

                for (const id of drag.ids) {
                    const n = getNode(id);
                    const s = drag.start.get(id);
                    if (!n || !s) continue;
                    n.updatePosition(s.x + dx, s.y + dy);
                }

                drag.snap = findSnapParentFor(drag.rootId, w);
                setSnapPreview(drag.snap, drag.rootId);

                markDrawDirty();
                return;
            }

            if (isPanning) {
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;
                view.panX = panStart.panX + dx;
                view.panY = panStart.panY + dy;
                cancelViewAnimation();
                markViewDirty();
            }
        });

        document.addEventListener('mouseup', () => {
            if (drag) {
                if (drag.snap) {
                    snapRootTo(drag.snap, drag.rootId);
                    markUnsaved();
                    commitHistory();
                } else if (drag.didMove || drag.detached) {
                    markUnsaved();
                    commitHistory();
                    applyAttachments();
                } else {
                    // Even if nothing moved, ensure stacks are in a consistent state
                    applyAttachments();
                }

                clearSnapPreview();
                drag = null;
                isDragging = false;
                draggedNode = null;
                didMoveNode = false;
            } else if (isDragging && didMoveNode) {
                // fallback (shouldn't happen)
                markUnsaved();
                commitHistory();
                isDragging = false;
                draggedNode = null;
                didMoveNode = false;
            }

            if (isPanning) {
                isPanning = false;
                canvasContainer.classList.remove('panning');
                markDrawDirty();
            }
        });

        // Panning by dragging empty space
        canvasContainer.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;
            if (e.target.closest('.controls')) return;
            if (e.target.closest('.node') && !(e.altKey)) return;
            if (e.target.closest('input') || e.target.closest('button')) return;

            cancelViewAnimation();
            isPanning = true;
            panStart = { x: e.clientX, y: e.clientY, panX: view.panX, panY: view.panY };
            canvasContainer.classList.add('panning');
            clearSelectedEndpoint();
            e.preventDefault();
        });

        // Wheel: zoom
        canvasContainer.addEventListener('wheel', (e) => {
            if (e.target.closest('.controls')) return;

            e.preventDefault();
            const factor = Math.exp(-e.deltaY * 0.001);
            const baseZoom = view.isZooming ? view.targetZoom : view.zoom;
            zoomAt(e.clientX, e.clientY, baseZoom * factor);
        }, { passive: false });

        // Add node on double-click (empty space)
        canvasContainer.addEventListener('dblclick', (e) => {
            if (e.target.closest('.controls')) return;
            if (e.target.closest('.node')) return;

            const w = screenToWorld(e.clientX, e.clientY);
            addNewNodeAt(w.x - 125, w.y - 50);
        });

        // Deselect node/connection on empty click
        canvasContainer.addEventListener('click', (e) => {
            if (e.target.closest('.controls')) return;
            if (e.target.closest('.node')) return;

            // Hit test for connections
            const rect = canvasContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            let hit = null;
            for (const conn of connections) {
                const fromNode = nodes.find(n => n.id === conn.from.nodeId);
                const toNode = nodes.find(n => n.id === conn.to.nodeId);
                if (!fromNode || !toNode) continue;
                const start = fromNode.getOutputPointCenter(conn.from.lineIndex, rect);
                const end = toNode.getInputPointCenter(rect);
                if (!start || !end) continue;

                if (isPointNearBezier(mouseX, mouseY, start.x, start.y, end.x, end.y, getConnectionHitRadius())) {
                    hit = conn;
                    break;
                }
            }

            if (hit) {
                selectedConnection = hit;
                selectedNode = null;
                document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
                updateConnectionUI();
                markDrawDirty();
            } else {
                selectNode(null);
                clearSelectedEndpoint();
            }
        });

        // Delegate connector clicks for scalability
        nodesContainer.addEventListener('click', (e) => {
            const out = e.target.closest('.connection-point');
            const inp = e.target.closest('.node-input-point');

            if (out) {
                e.stopPropagation();
                const _r = canvasContainer.getBoundingClientRect();
                lastPointerScreen = { x: e.clientX - _r.left, y: e.clientY - _r.top };
                const nodeId = out.dataset.nodeId;
                const lineIndex = parseInt(out.dataset.lineIndex, 10);
                handleEndpointClick({ type: 'output', nodeId, lineIndex }, out);
                return;
            }

            if (inp) {
                e.stopPropagation();
                const _r = canvasContainer.getBoundingClientRect();
                lastPointerScreen = { x: e.clientX - _r.left, y: e.clientY - _r.top };
                const nodeId = inp.dataset.nodeId;
                handleEndpointClick({ type: 'input', nodeId }, inp);
                return;
            }
        });

        nodesContainer.addEventListener('contextmenu', (e) => {
            const out = e.target.closest('.connection-point');
            if (!out) return;
            e.preventDefault();
            e.stopPropagation();
            const nodeId = out.dataset.nodeId;
            const lineIndex = parseInt(out.dataset.lineIndex, 10);
            deleteConnectionFromLine(nodeId, lineIndex);
        });


        function getConnectionScale() {
            const scale = view.zoom || 1;
            return Math.max(0.75, Math.min(2, scale));
        }

        function getConnectionHitRadius() {
            return Math.max(12, 14 * getConnectionScale());
        }

        function snapNodesToPixels() {
            const zoom = view.zoom || 1;
            if (!nodes.length || zoom === 0) return;
            const snap = window.devicePixelRatio || 1;

            for (const n of nodes) {
                if (!n || !n.element) continue;
                const screenX = view.panX + n.x * zoom;
                const screenY = view.panY + n.y * zoom;
                const snappedX = Math.round(screenX * snap) / snap;
                const snappedY = Math.round(screenY * snap) / snap;
                const dxWorld = (snappedX - screenX) / zoom;
                const dyWorld = (snappedY - screenY) / zoom;

                if (Math.abs(dxWorld) < 0.0005 && Math.abs(dyWorld) < 0.0005) {
                    n.element.style.transform = '';
                } else {
                    n.element.style.transform = `translate3d(${dxWorld}px, ${dyWorld}px, 0)`;
                }
            }
            snapsActive = true;
        }

        function clearNodePixelSnaps() {
            if (!snapsActive) return;
            for (const n of nodes) {
                if (!n || !n.element) continue;
                n.element.style.transform = '';
            }
            snapsActive = false;
        }

        function maybeSnapNodesToPixels() {
            if (!snapDirty) return;
            if (view.isZooming || isPanning || isDragging || drag) {
                clearNodePixelSnaps();
                return;
            }
            snapNodesToPixels();
            snapDirty = false;
        }

        function drawConnections() {
            ctx.clearRect(0, 0, viewport.width, viewport.height);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const containerRect = canvasContainer.getBoundingClientRect();

            for (const conn of connections) {
                const fromNode = nodes.find(n => n.id === conn.from.nodeId);
                const toNode = nodes.find(n => n.id === conn.to.nodeId);
                if (!fromNode || !toNode) continue;

                const start = fromNode.getOutputPointCenter(conn.from.lineIndex, containerRect);
                const end = toNode.getInputPointCenter(containerRect);
                if (!start || !end) continue;

                drawCurvedLine(start.x, start.y, end.x, end.y, conn === selectedConnection, conn);
            }

            // Ghost wiring: show a preview line from the selected endpoint to the pointer
            if (selectedEndpoint) {
                const n = nodes.find(nn => nn.id === selectedEndpoint.nodeId);
                if (n) {
                    const start = selectedEndpoint.type === 'output'
                        ? n.getOutputPointCenter(selectedEndpoint.lineIndex, containerRect)
                        : n.getInputPointCenter(containerRect);

                    const end = lastPointerScreen;
                    if (start && end) {
                        drawGhostLine(start.x, start.y, end.x, end.y);
                    }
                }
            }
        }

        function drawCurvedLine(x1, y1, x2, y2, isSelected = false, conn = null) {
            // Evaluate condition for pass/fail display (from either manual expression or multi-row builder)
            let expr = '';
            try {
                if (conn) {
                    ensureConnectionConditionModel(conn);
                    if (conn.condition && String(conn.condition).trim()) {
                        expr = String(conn.condition).trim();
                    } else {
                        expr = buildExpressionFromConditions(conn.conditions || [], conn.conditionLogic || 'AND');
                    }
                }
            } catch (err) {
                // If anything goes wrong evaluating conditions, just draw a normal line.
                expr = '';
            }

            const evalResult = expr ? evaluateCondition(expr) : { passes: true, hasCondition: false };
            const hasCondition = !!(evalResult && evalResult.hasCondition);
            const passes = evalResult ? !!evalResult.passes : true;
            const scale = getConnectionScale();

            const controlPointOffset = Math.abs(x2 - x1) * 0.5;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.bezierCurveTo(
                x1 + controlPointOffset, y1,
                x2 - controlPointOffset, y2,
                x2, y2
            );

            // Color based on condition pass/fail
            let lineColor = isSelected ? '#ff9800' : '#007acc';
            if (hasCondition && !isSelected) {
                lineColor = passes ? '#27ae60' : '#c0392b';
            }

            ctx.strokeStyle = lineColor;
            ctx.lineWidth = (isSelected ? 4 : 2) * scale;
            ctx.stroke();

            // Arrow
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const arrowSize = 8 * scale;
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(
                x2 - arrowSize * Math.cos(angle - Math.PI / 6),
                y2 - arrowSize * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                x2 - arrowSize * Math.cos(angle + Math.PI / 6),
                y2 - arrowSize * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fillStyle = lineColor;
            ctx.fill();

            // Condition badge (pass/fail indicator)
            if (hasCondition) {
                const mid = getBezierPoint(0.5, x1, y1, x2, y2);
                const bx = mid.x;
                const by = mid.y;

                // Badge circle
                ctx.fillStyle = passes ? '#27ae60' : '#e74c3c';
                ctx.beginPath();
                ctx.arc(bx, by, 12 * scale, 0, Math.PI * 2);
                ctx.fill();

                // White border for visibility
                ctx.strokeStyle = 'white';
                ctx.lineWidth = Math.max(1, 2 * scale);
                ctx.stroke();

                // Check or X symbol
                ctx.fillStyle = 'white';
                ctx.font = `bold ${Math.round(14 * scale)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(passes ? '‚úì' : '‚úó', bx, by);
            }
        }

        function getBezierPoint(t, x1, y1, x2, y2) {
            const cpOffset = Math.abs(x2 - x1) * 0.5;
            const cx1 = x1 + cpOffset, cy1 = y1;
            const cx2 = x2 - cpOffset, cy2 = y2;
            const x = Math.pow(1 - t, 3) * x1 + 3 * Math.pow(1 - t, 2) * t * cx1 + 3 * (1 - t) * Math.pow(t, 2) * cx2 + Math.pow(t, 3) * x2;
            const y = Math.pow(1 - t, 3) * y1 + 3 * Math.pow(1 - t, 2) * t * cy1 + 3 * (1 - t) * Math.pow(t, 2) * cy2 + Math.pow(t, 3) * y2;
            return { x, y };
        }

        function isPointNearBezier(px, py, x1, y1, x2, y2, threshold = 16) {
            for (let t = 0; t <= 1; t += 0.03) {
                const pt = getBezierPoint(t, x1, y1, x2, y2);
                const dist = Math.sqrt(Math.pow(px - pt.x, 2) + Math.pow(py - pt.y, 2));
                if (dist < threshold) return true;
            }
            return false;
        }

        
function tryParseFlatConditionsFromExpression(expr) {
            const raw = normalizeConditionExpression(expr || '');
            if (!raw) return { logic: 'AND', conditions: [] };

            const hasOr = /(?:\|\||\bor\b)/i.test(raw);
            const hasAnd = /(?:&&|\band\b)/i.test(raw);

            // If it's a mixed OR+AND expression, keep it as manual-only.
            if (hasOr && hasAnd) return null;

            const logic = hasOr ? 'OR' : 'AND';
            const parts = hasOr
                ? raw.split(/\s*(?:\|\||\bor\b)\s*/i)
                : raw.split(/\s*(?:&&|\band\b)\s*/i);

            const conditions = [];
            for (const p of parts.map(s => s.trim()).filter(Boolean)) {
                const parsed = parseAtomicCondition(p);
                if (!parsed) continue;
                conditions.push({ varName: parsed.varName, operator: parsed.operator, value: String(parsed.rawValue).trim() });
            }
            return { logic, conditions };
        }

        function buildExpressionFromConditions(conditions, logic) {
            const joiner = (logic === 'OR') ? ' or ' : ' and ';
            const usable = (conditions || []).filter(c => c && c.varName && String(c.value ?? '').trim() !== '');
            return usable.map(c => `${c.varName} ${c.operator || '>='} ${String(c.value).trim()}`).join(joiner);
        }

        function ensureConnectionConditionModel(conn) {
            if (!conn) return;
            if (!Array.isArray(conn.conditions)) {
                const parsed = tryParseFlatConditionsFromExpression(conn.condition || '');
                if (parsed) {
                    conn.conditions = parsed.conditions;
                    conn.conditionLogic = parsed.logic;
                } else {
                    conn.conditions = [];
                    conn.conditionLogic = 'AND';
                }
            }
            if (!conn.conditionLogic) conn.conditionLogic = 'AND';
            if (!conn.condition || !String(conn.condition).trim()) {
                // If no manual expression exists, generate from conditions
                const gen = buildExpressionFromConditions(conn.conditions, conn.conditionLogic);
                if (gen) conn.condition = gen;
            }
        }

        
        function getProjectVariableNames() {
            try {
                return (project?.entities?.variables || []).map(v => v?.name).filter(Boolean);
            } catch (e) {
                return [];
            }
        }

        function populateConnSetVarOptions() {
            const sel = document.getElementById('connSetVar');
            if (!sel) return;

            const current = sel.value || '';
            const vars = getProjectVariableNames();

            // Rebuild options
            sel.innerHTML = '';
            const o0 = document.createElement('option');
            o0.value = '';
            o0.textContent = '-- None --';
            sel.appendChild(o0);

            for (const name of vars) {
                const o = document.createElement('option');
                o.value = name;
                o.textContent = name;
                sel.appendChild(o);
            }

            // Restore selection if still valid
            if (vars.includes(current)) sel.value = current;
        }

function buildConnConditionRow(cond, index) {
            const row = document.createElement('div');
            row.className = 'conn-cond-row';
            row.style.display = 'flex';
            row.style.gap = '6px';
            row.style.alignItems = 'center';

            const varSel = document.createElement('select');
            varSel.style.flex = '1';
            varSel.style.padding = '6px';
            varSel.style.borderRadius = '6px';
            varSel.style.border = '1px solid var(--border-secondary)';
            varSel.style.background = 'var(--input-bg)';
            varSel.style.color = 'var(--text-primary)';
            varSel.style.fontSize = '12px';

            const opt0 = document.createElement('option');
            opt0.value = '';
            opt0.textContent = '-- Variable --';
            varSel.appendChild(opt0);

            const vars = (project?.entities?.variables || []).map(v => v?.name).filter(Boolean);
            for (const name of vars) {
                const o = document.createElement('option');
                o.value = name;
                o.textContent = name;
                varSel.appendChild(o);
            }

            const opSel = document.createElement('select');
            opSel.style.width = '70px';
            opSel.style.padding = '6px';
            opSel.style.borderRadius = '6px';
            opSel.style.border = '1px solid var(--border-secondary)';
            opSel.style.background = 'var(--input-bg)';
            opSel.style.color = 'var(--text-primary)';
            opSel.style.fontSize = '12px';

            ['>=','<=','>','<','==','!='].forEach(op => {
                const o = document.createElement('option');
                o.value = op;
                o.textContent = op;
                opSel.appendChild(o);
            });

            const valInput = document.createElement('input');
            valInput.type = 'text';
            valInput.placeholder = 'value';
            valInput.style.width = '84px';
            valInput.style.padding = '6px';
            valInput.style.borderRadius = '6px';
            valInput.style.border = '1px solid var(--border-secondary)';
            valInput.style.background = 'var(--input-bg)';
            valInput.style.color = 'var(--text-primary)';
            valInput.style.fontSize = '12px';

            const rmBtn = document.createElement('button');
            rmBtn.textContent = '√ó';
            rmBtn.className = 'danger';
            rmBtn.title = 'Remove condition';
            rmBtn.style.width = '34px';

            varSel.value = cond?.varName || '';
            opSel.value = cond?.operator || '>=';
            valInput.value = (cond?.value ?? '');

            const sync = () => {
                if (!selectedConnection) return;
                ensureConnectionConditionModel(selectedConnection);
                const list = selectedConnection.conditions;
                const c = list[index] || {};
                c.varName = varSel.value;
                c.operator = opSel.value;
                c.value = valInput.value;
                list[index] = c;

                // Keep the manual expression in sync (flat expressions only)
                const logicSel = document.getElementById('connLogic');
                selectedConnection.conditionLogic = logicSel?.value || selectedConnection.conditionLogic || 'AND';

                const gen = buildExpressionFromConditions(list, selectedConnection.conditionLogic);
                selectedConnection.condition = gen; // overwrite manual when using the builder
                const area = document.getElementById('connCondition');
                if (area) area.value = gen;

                updateConditionPreview();
                markUnsaved();
                markDrawDirty();
            };

            varSel.addEventListener('change', sync);
            opSel.addEventListener('change', sync);
            valInput.addEventListener('input', debounce(sync, 120));

            rmBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!selectedConnection) return;
                ensureConnectionConditionModel(selectedConnection);
                selectedConnection.conditions.splice(index, 1);
                renderConnectionConditionsUI();
                updateConditionPreview();
                markUnsaved();
                markDrawDirty();
            });

            row.appendChild(varSel);
            row.appendChild(opSel);
            row.appendChild(valInput);
            row.appendChild(rmBtn);
            return row;
        }

        function renderConnectionConditionsUI() {
            const listEl = document.getElementById('connConditionsList');
            const logicSel = document.getElementById('connLogic');
            const addBtn = document.getElementById('addConnConditionBtn');

            if (!listEl) return;

            const enabled = !!selectedConnection;

            if (logicSel) {
                logicSel.disabled = !enabled;
                logicSel.style.opacity = enabled ? '1' : '0.65';
            }
            if (addBtn) {
                addBtn.disabled = !enabled;
                addBtn.style.opacity = enabled ? '1' : '0.65';
            }

            listEl.innerHTML = '';

            if (!enabled) {
                const hint = document.createElement('div');
                hint.style.fontSize = '11px';
                hint.style.color = 'var(--text-secondary)';
                hint.textContent = 'Select a connection to edit its conditions.';
                listEl.appendChild(hint);
                return;
            }

            ensureConnectionConditionModel(selectedConnection);

            if (logicSel) logicSel.value = selectedConnection.conditionLogic || 'AND';

            const conds = selectedConnection.conditions || [];
            if (!conds.length) {
                conds.push({ varName: '', operator: '>=', value: '' });
                selectedConnection.conditions = conds;
            }

            conds.forEach((c, i) => {
                listEl.appendChild(buildConnConditionRow(c, i));
            });
        }

        function updateConnectionUI() {
            const panel = document.getElementById('connectionProperties');
            const area = document.getElementById('connCondition');
            const preview = document.getElementById('conditionPreview');
            const setVarSelect = document.getElementById('connSetVar');
            const setValInput = document.getElementById('connSetValue');
            const meta = document.getElementById('connPickerMeta');

            // Keep panel visible so you can pick a connection even if clicking lines is tricky
            if (panel) panel.style.display = 'block';

            refreshConnectionPicker();
            populateConnSetVarOptions();
            setConnectionControlsEnabled(!!selectedConnection);

            if (!selectedConnection) {
                if (area) area.value = '';
                renderConnectionConditionsUI();
                if (preview) preview.innerHTML = '<span style="color:var(--text-secondary);">Select a connection to evaluate its condition.</span>';
                if (meta) meta.textContent = '';
                return;
            }

            ensureConnectionConditionModel(selectedConnection);

            // Manual expression box mirrors the current expression
            if (area) area.value = selectedConnection.condition || buildExpressionFromConditions(selectedConnection.conditions, selectedConnection.conditionLogic);

            renderConnectionConditionsUI();

            // Set "set variable" fields
            if (setVarSelect) setVarSelect.value = selectedConnection.setVar || '';
            if (setValInput) setValInput.value = selectedConnection.setValue || '';

            // Meta label
            if (meta) {
                const fromNode = nodes.find(n => n.id === selectedConnection.from.nodeId);
                const toNode = nodes.find(n => n.id === selectedConnection.to.nodeId);
                const fromLabel = fromNode ? (`#${fromNode.number || ''} ${fromNode.title || fromNode.type || 'Node'}`) : selectedConnection.from.nodeId;
                const toLabel = toNode ? (`#${toNode.number || ''} ${toNode.title || toNode.type || 'Node'}`) : selectedConnection.to.nodeId;
                meta.textContent = `${fromLabel} ‚Üí ${toLabel}`;
            }

            updateConditionPreview();
        }

function parseConditionToUI(conditionStr) { /* legacy no-op (multi-condition UI in use) */ }

        function buildConditionFromUI() { return ''; }

        
function updateConditionPreview() {
            const preview = document.getElementById('conditionPreview');

            if (!preview) return;

            if (!selectedConnection) {
                preview.innerHTML = '<span style="color:var(--text-secondary);">Select a connection to evaluate its condition.</span>';
                return;
            }

            // Prefer explicit expression; otherwise build from the condition rows
            const expr = (selectedConnection.condition && String(selectedConnection.condition).trim())
                ? selectedConnection.condition
                : buildExpressionFromConditions(selectedConnection.conditions || [], selectedConnection.conditionLogic || 'AND');

            if (!expr || !String(expr).trim()) {
                preview.innerHTML = '<em style="color:var(--text-secondary)">No condition set ‚Äî connection always available</em>';
                return;
            }

            const result = evaluateCondition(expr);

            if (!result.hasCondition) {
                preview.innerHTML = '<em style="color:var(--text-secondary)">No condition set</em>';
                return;
            }

            const head = result.passes
                ? `<span style="color:#27ae60; font-weight:bold;">‚úì PASSES</span>`
                : `<span style="color:#c0392b; font-weight:bold;">‚úó FAILS</span>`;

            const count = (result.totalCount > 1)
                ? `<span style="margin-left:6px; color:var(--text-secondary);">(${result.passedCount}/${result.totalCount})</span>`
                : '';

            let body = '';
            if (Array.isArray(result.details) && result.details.length) {
                const rows = result.details.map(d => {
                    const ok = !!d.passes;
                    const icon = ok ? '‚úì' : '‚úó';
                    const color = ok ? '#27ae60' : '#c0392b';
                    const valPart = (d.varName !== undefined && d.actualValue !== undefined)
                        ? ` <span style="color:var(--text-secondary);">(${d.varName}=${d.actualValue})</span>`
                        : '';
                    const label = (d.text || d.reason || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    return `<div style="margin-top:4px;"><span style="color:${color}; font-weight:bold;">${icon}</span> <span>${label}</span>${valPart}</div>`;
                }).join('');
                body = `<div style="margin-top:6px;">${rows}</div>`;
            } else {
                body = `<div style="margin-top:6px; color:var(--text-secondary);">${result.reason || ''}</div>`;
            }

            preview.innerHTML = head + count + body;
        }


        function executeConnectionAction(conn) {
            if (!conn.setVar) return;
            const success = setVariableValue(conn.setVar, conn.setValue);
            if (success) {
                console.log(`Connection traversal: set ${conn.setVar} = ${conn.setValue}`);
            }
        }



        function drawGhostLine(x1, y1, x2, y2) {
            const controlPointOffset = Math.abs(x2 - x1) * 0.5;
            const scale = getConnectionScale();

            ctx.save();
            ctx.globalAlpha = 0.55;
            ctx.strokeStyle = '#00c853';
            ctx.lineWidth = 2 * scale;
            ctx.setLineDash([6 * scale, 6 * scale]);

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.bezierCurveTo(
                x1 + controlPointOffset, y1,
                x2 - controlPointOffset, y2,
                x2, y2
            );
            ctx.stroke();

            // small endpoint dot (helps readability)
            ctx.setLineDash([]);
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = '#00c853';
            ctx.beginPath();
            ctx.arc(x2, y2, 3 * scale, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function updateConnectionVisuals() {
            document.querySelectorAll('.dialogue-line').forEach(line => line.classList.remove('has-connection'));

            connections.forEach(conn => {
                const node = nodes.find(n => n.id === conn.from.nodeId);
                if (!node || !node.element) return;
                const lines = node.element.querySelectorAll('.dialogue-line');
                if (lines[conn.from.lineIndex]) lines[conn.from.lineIndex].classList.add('has-connection');
            });
            ensureConnectionIds();
            refreshConnectionPicker();
        }

        function getDataObject() {
            return {
                nodes: nodes.map(n => ({
                    id: n.id,
                    number: n.number,
                    title: n.title,
                    lines: n.lines,
                    position: { x: n.x, y: n.y },
                    color: n.color,
                    type: n.type,
                    attach_to: n.attach_to,
                    attach_side: n.attach_side,
                    attach_order: n.attach_order
                })),
                connections: connections.map(c => ({
                    from_node: c.from.nodeId,
                    from_line: c.from.lineIndex,
                    to_node: c.to.nodeId,
                    condition: c.condition || '',
                    setVar: c.setVar || '',
                    setValue: c.setValue || ''
                })),
                metadata: {
                    version: '3.2',
                    created: new Date().toISOString(),
                    nodeCounter: nodeIdCounter,
                    attachOrderCounter
                }
            };
        }

        function loadDataObject(data) {
            nodesContainer.innerHTML = '';
            nodes = [];
            connections = [];
            selectedNode = null;
            clearSelectedEndpoint();
            attachOrderCounter = 0;

            if (data.metadata && typeof data.metadata.nodeCounter === 'number') {
                nodeIdCounter = data.metadata.nodeCounter;
            } else {
                // Best-effort: keep IDs unique if metadata missing
                const maxId = (data.nodes || []).reduce((m, n) => {
                    const match = String(n.id || '').match(/node_(\d+)/);
                    return match ? Math.max(m, parseInt(match[1], 10) + 1) : m;
                }, 0);
                nodeIdCounter = Math.max(nodeIdCounter, maxId);
            }

            // Attachment order counter (for stable stacking)
            if (data.metadata && typeof data.metadata.attachOrderCounter === 'number') {
                attachOrderCounter = data.metadata.attachOrderCounter;
            } else {
                const maxOrder = (data.nodes || []).reduce((m, n) => Math.max(m, (n.attach_order || 0)), 0);
                attachOrderCounter = Math.max(attachOrderCounter, maxOrder);
            }

            // Back-compat numbering
            let fallbackNum = 1;

            (data.nodes || []).forEach(nodeData => {
                const number = (typeof nodeData.number === 'number')
                    ? nodeData.number
                    : (() => {
                        const m = String(nodeData.id || '').match(/node_(\d+)/);
                        return m ? parseInt(m[1], 10) + 1 : (fallbackNum++);
                    })();

                const node = new Node(
                    nodeData.id,
                    number,
                    nodeData.title,
                    nodeData.lines,
                    nodeData.position.x,
                    nodeData.position.y,
                    nodeData.color,
                    nodeData.type || 'normal',
                    nodeData.attach_to || null,
                    nodeData.attach_side || 'bottom',
                    nodeData.attach_order || 0
                );
                nodes.push(node);
            });

            connections = (data.connections || []).map(c => ({
                from: { nodeId: c.from_node, lineIndex: c.from_line },
                to: { nodeId: c.to_node },
                condition: c.condition || '',
                setVar: c.setVar || '',
                setValue: c.setValue || ''
            }));

            applyAttachments();
            updateConnectionVisuals();
            markDrawDirty();
        }

        function saveToFile() {
            const data = getDataObject();
            const jsonStr = JSON.stringify(data, null, 2);

            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'narrative_flow_' + new Date().toISOString().slice(0, 10) + '.json';
            a.click();
            URL.revokeObjectURL(url);

            lastSavedState = jsonStr;
            hasUnsavedChanges = false;
            updateSaveIndicator();
        }

        function triggerLoadFile() {
            document.getElementById('fileInput').click();
        }

        function loadFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (hasUnsavedChanges) {
                if (!confirm('You have unsaved changes. Load anyway?')) {
                    event.target.value = '';
                    return;
                }
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    loadDataObject(data);
                    lastSavedState = e.target.result;
                    hasUnsavedChanges = false;
                    updateSaveIndicator();
                    initHistory();
                } catch (error) {
                    alert('Error loading file: ' + error.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function markUnsaved() {
            if (hasUnsavedChanges) return;
            hasUnsavedChanges = true;
            updateSaveIndicator();
        }

        function updateSaveIndicator() {
            const indicator = document.getElementById('saveIndicator');
            if (hasUnsavedChanges) {
                indicator.textContent = '‚óè Unsaved changes';
                indicator.className = 'save-indicator unsaved';
            } else {
                indicator.textContent = '‚úì Saved';
                indicator.className = 'save-indicator saved';
            }
        }


        document.addEventListener('keydown', (e) => {
            const key = (e.key || '').toLowerCase();
            const ctrl = e.ctrlKey || e.metaKey;
            const active = document.activeElement;

            // Save
            if (ctrl && key === 's') {
                e.preventDefault();
                saveToFile();
                return;
            }

            // Delete key: sidebar selection (if sidebar was last clicked), otherwise graph selection
            if (e.key === 'Delete' && !isEditableElement(active)) {
                if (lastFocusArea === 'sidebar') {
                    e.preventDefault();
                    deleteSidebarSelection();
                    return;
                }
                if (isGraphActivePane() && selectedNode) {
                    e.preventDefault();
                    deleteSelectedNode();
                    return;
                }
            }

            // Fit view (F)
            if (!ctrl && !e.altKey && !e.shiftKey && key === 'f' && !isEditableElement(active)) {
                e.preventDefault();
                fitView();
                return;
            }

            // Undo / Redo (route by last focus area)
            if (ctrl && key === 'z' && !e.shiftKey && !isEditableElement(active)) {
                e.preventDefault();
                if (lastFocusArea === 'sidebar') projectUndo();
                else if (isGraphActivePane()) undo();
                return;
            }

            // Ctrl+Y or Ctrl+Shift+Z
            if (ctrl && (key === 'y' || (key === 'z' && e.shiftKey)) && !isEditableElement(active)) {
                e.preventDefault();
                if (lastFocusArea === 'sidebar') projectRedo();
                else if (isGraphActivePane()) redo();
                return;
            }
        });


        // ---------------- Project + Sidebar (lightweight, iterative) ----------------
        const LS_PROJECT_KEY = 'narrativeFlowProject_v1';

        let project = null; // { version, title, graphs, entities, ui }
        let currentGraphId = null;
        let editingEntityRef = null; // { kind, id }
        let lastSidebarWidth = 280;


        // Sidebar-level undo/redo (project snapshot history). Excludes per-graph history stacks.
        let projectUndoStack = [];
        let projectRedoStack = [];
        let isRestoringProjectHistory = false;
        let lastFocusArea = 'graph';

        function snapshotProjectForHistory() {
            return JSON.stringify(project, (k, v) => (k === 'history' ? undefined : v));
        }

        function initProjectHistory() {
            projectUndoStack = [snapshotProjectForHistory()];
            projectRedoStack = [];
        }

        function commitProjectHistory() {
            if (isRestoringProjectHistory) return;
            const snap = snapshotProjectForHistory();
            if (!projectUndoStack.length || projectUndoStack[projectUndoStack.length - 1] !== snap) {
                projectUndoStack.push(snap);
                if (projectUndoStack.length > 120) projectUndoStack.shift();
            }
            projectRedoStack = [];
        }

        function restoreProjectSnapshot(snap) {
            isRestoringProjectHistory = true;
            try {
                project = JSON.parse(snap);
                project.ui = ensureExpandedDefaults(project.ui || {});
                ensureNav(project);

                // Restore selected graph to canvas
                const gid = project.ui.selectedGraphId || project.graphs[0]?.id || null;
                project.ui.selectedGraphId = gid;

                if (gid) {
                    applyGraphFromProject(gid, { skipPersist: true });
                    initHistory();
                }

                renderSidebarTree();

                const sel = project.ui.selection;
                if (sel?.kind === 'folder') {
                    const fsel = parseFolderSelection(sel);
                    if (fsel) selectFolder(fsel.category, fsel.folderId || null, { skipAutosave: true });
                } else if (sel?.kind && sel?.id) {
                    selectInTree(sel.kind, sel.id);
                } else if (gid) {
                    selectInTree('graph', gid);
                }

                markUnsaved();
                updateSaveIndicator();
            } finally {
                isRestoringProjectHistory = false;
            }
        }

        function projectUndo() {
            if (projectUndoStack.length <= 1) return;
            const cur = projectUndoStack.pop();
            projectRedoStack.push(cur);
            restoreProjectSnapshot(projectUndoStack[projectUndoStack.length - 1]);
        }

        function projectRedo() {
            if (!projectRedoStack.length) return;
            const nxt = projectRedoStack.pop();
            projectUndoStack.push(nxt);
            restoreProjectSnapshot(nxt);
        }

        function uid(prefix) {
            const rand = Math.random().toString(36).slice(2, 8);
            return `${prefix}_${Date.now().toString(36)}_${rand}`;
        }

        function ensureExpandedDefaults(ui) {
            ui.expanded = ui.expanded || {};
            const def = {
                views: true,
                entities: true,
                characters: true,
                items: true,
                locations: false,
                variables: true,
                docs: false
            };
            for (const k of Object.keys(def)) if (typeof ui.expanded[k] !== 'boolean') ui.expanded[k] = def[k];
            if (typeof ui.sidebarWidth !== 'number') ui.sidebarWidth = 280;
            if (typeof ui.sidebarCollapsed !== 'boolean') ui.sidebarCollapsed = false;
            if (!ui.selection) ui.selection = { kind: 'graph', id: null };
            return ui;
        }

        // ---- Sidebar tree model (virtual folders + files) ----
        // project.nav keeps folder structure for each section; leaf nodes reference graphs/entities by id.
        // Format:
        //   project.nav[category] = [{ id, parentId, kind:'folder'|'leaf', name?, refKind?, refId? }]
        // Categories: views, characters, items, locations, docs
        function ensureNav(p) {
            if (!p) return;
            if (!p.nav || typeof p.nav !== 'object') {
                p.nav = { views: [], characters: [], items: [], locations: [], variables: [], docs: [] };
            }
            const cats = ['views', 'characters', 'items', 'locations', 'variables', 'docs'];
            for (const c of cats) if (!Array.isArray(p.nav[c])) p.nav[c] = [];

            const hasLeaf = (arr, refKind, refId) => arr.some(n => n && n.kind === 'leaf' && n.refKind === refKind && n.refId === refId);

            const hasLeafAnywhere = (refKind, refId) => {
                const cats = ['views', 'characters', 'items', 'locations', 'variables', 'docs'];
                for (const c of cats) {
                    const arr = p.nav[c] || [];
                    if (hasLeaf(arr, refKind, refId)) return true;
                }
                return false;
            };

            // Add missing graph leaves
            for (const g of (p.graphs || [])) {
                if (!g || !g.id) continue;
                if (!hasLeafAnywhere('graph', g.id)) {
                    p.nav.views.push({ id: uid('nav'), parentId: null, kind: 'leaf', refKind: 'graph', refId: g.id });
                }
            }

            // Add missing entity leaves
            const addEntLeaves = (bucket, category, refKind) => {
                for (const e of (bucket || [])) {
                    if (!e || !e.id) continue;
                    if (!hasLeafAnywhere(refKind, e.id)) {
                        p.nav[category].push({ id: uid('nav'), parentId: null, kind: 'leaf', refKind, refId: e.id });
                    }
                }
            };
            addEntLeaves(p.entities?.characters, 'characters', 'character');
            addEntLeaves(p.entities?.items, 'items', 'item');
            addEntLeaves(p.entities?.locations, 'locations', 'location');
            addEntLeaves(p.entities?.variables, 'variables', 'variable');
            addEntLeaves(p.entities?.notes, 'docs', 'note');

            // Prune leaves that point to missing data (keeps tree clean after deletes)
            const validGraph = new Set((p.graphs || []).map(g => g.id));
            const validEnt = {
                character: new Set((p.entities?.characters || []).map(e => e.id)),
                item: new Set((p.entities?.items || []).map(e => e.id)),
                location: new Set((p.entities?.locations || []).map(e => e.id)),
                variable: new Set((p.entities?.variables || []).map(e => e.id)),
                note: new Set((p.entities?.notes || []).map(e => e.id)),
            };
            const prune = (category) => {
                p.nav[category] = (p.nav[category] || []).filter(n => {
                    if (!n) return false;
                    if (n.kind === 'folder') return true;
                    if (n.kind === 'leaf') {
                        if (n.refKind === 'graph') return validGraph.has(n.refId);
                        const set = validEnt[n.refKind];
                        return set ? set.has(n.refId) : false;
                    }
                    return false;
                });
            };
            prune('views'); prune('characters'); prune('items'); prune('locations'); prune('variables'); prune('docs');
        }

        function folderSelId(category, folderId) {
            return `folder:${category}:${folderId || 'root'}`;
        }
        function navExpandKey(category, folderId) {
            return `nav:${category}:${folderId}`;
        }
        function categoryForKind(kind) {
            if (kind === 'graph') return 'views';
            if (kind === 'character') return 'characters';
            if (kind === 'item') return 'items';
            if (kind === 'location') return 'locations';
            if (kind === 'variable') return 'variables';
            if (kind === 'note') return 'docs';
            return null;
        }
        function navList(category) {
            return (project && project.nav && Array.isArray(project.nav[category])) ? project.nav[category] : [];
        }
        function navGet(category, navId) {
            return navList(category).find(n => n.id === navId) || null;
        }
        function navChildren(category, parentId) {
            return navList(category).filter(n => (n.parentId || null) === (parentId || null));
        }
        function navFindLeafByRef(category, refKind, refId) {
            return navList(category).find(n => n.kind === 'leaf' && n.refKind === refKind && n.refId === refId) || null;
        }

        function navFindLeafAnywhere(refKind, refId) {
            const cats = ['views', 'characters', 'items', 'locations', 'variables', 'docs'];
            for (const c of cats) {
                const leaf = navFindLeafByRef(c, refKind, refId);
                if (leaf) return { category: c, node: leaf };
            }
            return null;
        }

        function navCollectSubtreeIds(category, folderId) {
            const arr = navList(category);
            const byParent = new Map();
            for (const n of arr) {
                const pid = (n.parentId || null);
                if (!byParent.has(pid)) byParent.set(pid, []);
                byParent.get(pid).push(n);
            }
            const out = new Set();
            const stack = [folderId];
            while (stack.length) {
                const cur = stack.pop();
                if (out.has(cur)) continue;
                out.add(cur);
                const kids = byParent.get(cur) || [];
                for (const k of kids) {
                    out.add(k.id);
                    if (k.kind === 'folder') stack.push(k.id);
                }
            }
            return out;
        }

        function navIsDescendant(category, rootFolderId, maybeFolderId) {
            if (!maybeFolderId) return false;
            if (rootFolderId === maybeFolderId) return true;
            const arr = navList(category);
            const map = new Map(arr.map(n => [n.id, n]));
            let cur = map.get(maybeFolderId);
            while (cur) {
                const pid = cur.parentId || null;
                if (!pid) return false;
                if (pid === rootFolderId) return true;
                cur = map.get(pid);
            }
            return false;
        }

        function navRemoveLeafByRef(category, refKind, refId) {
            const arr = navList(category);
            const idx = arr.findIndex(n => n.kind === 'leaf' && n.refKind === refKind && n.refId === refId);
            if (idx >= 0) arr.splice(idx, 1);
        }
        function navRemoveSubtree(category, folderId) {
            const arr = navList(category);
            const toRemove = new Set();
            const walk = (pid) => {
                for (const n of arr) {
                    if ((n.parentId || null) === (pid || null)) {
                        toRemove.add(n.id);
                        if (n.kind === 'folder') walk(n.id);
                    }
                }
            };
            walk(folderId);
            // remove nodes
            for (let i = arr.length - 1; i >= 0; i--) {
                if (toRemove.has(arr[i].id)) arr.splice(i, 1);
            }
        }

        function selectFolder(category, folderId, opts = {}) {
            if (!project) return;
            project.ui.selection = { kind: 'folder', id: folderSelId(category, folderId), category, folderId: folderId || null };
            updateCrumbsForSelection(project.ui.selection);
            updateSidebarSelectionHighlight('folder', project.ui.selection.id);
            if (!opts.skipAutosave) scheduleLocalAutosave();
        }

        function labelForLeaf(refKind, refId) {
            if (refKind === 'graph') {
                const g = project?.graphs?.find(x => x.id === refId);
                return g ? (g.name || 'Graph') : 'Missing graph';
            }
            const ent = findEntity(refKind, refId);
            return ent ? (ent.name || refKind) : `Missing ${refKind}`;
        }

        function folderPathNames(category, folderId) {
            const names = [];
            let cur = folderId ? navGet(category, folderId) : null;
            let guard = 0;
            while (cur && guard++ < 64) {
                if (cur.name) names.push(cur.name);
                cur = cur.parentId ? navGet(category, cur.parentId) : null;
            }
            names.reverse();
            return names;
        }

        function makeEmptyGraph(name) {
            const g = {
                id: uid('graph'),
                name: name || 'New Graph',
                data: {
                    nodes: [],
                    connections: [],
                    metadata: {
                        version: '3.2',
                        created: new Date().toISOString(),
                        nodeCounter: 0,
                        attachOrderCounter: 0
                    }
                },
                view: { panX: 0, panY: 0, zoom: 1 },
                history: { undoStack: [], redoStack: [] }
            };
            return g;
        }

        function makeEntity(kind, name) {
            return {
                id: uid(kind),
                kind,
                name: name || (kind[0].toUpperCase() + kind.slice(1)),
                technical: '',
                objectId: '',
                quantity: 1,
                varType: kind === 'variable' ? 'boolean' : '',
                initialValue: kind === 'variable' ? 'false' : '',
                tags: [],
                description: '',
                code: '',
                created: new Date().toISOString(),
                updated: new Date().toISOString()
            };
        }

        function projectExportObject() {
            // Persist current graph into project before exporting
            persistCurrentGraphIntoProject();

            // Keep export small: omit history
            return {
                project_version: '0.1',
                title: project?.title || 'Project',
                graphs: (project?.graphs || []).map(g => ({
                    id: g.id,
                    name: g.name,
                    data: g.data,
                    view: g.view
                })),
                entities: project?.entities || { characters: [], items: [], locations: [], variables: [], notes: [] },
                nav: project?.nav || null,
                ui: project?.ui ? {
                    expanded: project.ui.expanded,
                    sidebarWidth: project.ui.sidebarWidth,
                    sidebarCollapsed: project.ui.sidebarCollapsed,
                    selectedGraphId: project.ui.selectedGraphId || null
                } : {},
                exported_at: new Date().toISOString()
            };
        }

        let autosaveTimer = null;
        function scheduleLocalAutosave() {
            if (!project) return;
            clearTimeout(autosaveTimer);
            autosaveTimer = setTimeout(() => {
                try {
                    // Store a compact version (no history)
                    const obj = projectExportObject();
                    localStorage.setItem(LS_PROJECT_KEY, JSON.stringify(obj));
                } catch (err) {
                    console.warn('Local autosave failed:', err);
                }
            }, 400);
        }

        function loadProjectFromLocal() {
            try {
                const raw = localStorage.getItem(LS_PROJECT_KEY);
                if (!raw) return null;
                const obj = JSON.parse(raw);
                // basic validation
                if (!obj || !Array.isArray(obj.graphs)) return null;
                const p = {
                    version: obj.project_version || '0.1',
                    title: obj.title || 'Project',
                    graphs: obj.graphs.map(g => ({
                        id: g.id,
                        name: g.name || 'Graph',
                        data: g.data || { nodes: [], connections: [], metadata: { version: '3.2', created: new Date().toISOString(), nodeCounter: 0, attachOrderCounter: 0 } },
                        view: g.view || { panX: 0, panY: 0, zoom: 1 },
                        history: { undoStack: [], redoStack: [] }
                    })),
                    entities: obj.entities || { characters: [], items: [], locations: [], notes: [] },
                    nav: obj.nav || null,
                    nav: obj.nav || null,
                    ui: ensureExpandedDefaults(obj.ui || {})
                };
                ensureNav(p);
                // pick a graph
                const selected = p.ui.selectedGraphId && p.graphs.find(g => g.id === p.ui.selectedGraphId)
                    ? p.ui.selectedGraphId
                    : (p.graphs[0]?.id || null);
                p.ui.selectedGraphId = selected;
                p.ui.selection = { kind: 'graph', id: selected };
                return p;
            } catch (e) {
                console.warn('Could not load local project:', e);
                return null;
            }
        }

        function persistCurrentGraphIntoProject() {
            if (!project || !currentGraphId) return;
            const g = project.graphs.find(x => x.id === currentGraphId);
            if (!g) return;
            g.data = getDataObject();
            g.view = { panX: view.panX, panY: view.panY, zoom: view.zoom };
            // keep per-graph history in memory only
            g.history = { undoStack: undoStack.slice(), redoStack: redoStack.slice() };
            project.ui.selectedGraphId = currentGraphId;
            scheduleLocalAutosave();
        }

        function applyGraphFromProject(graphId, { skipPersist = false } = {}) {
            if (!project) return;
            if (!skipPersist) persistCurrentGraphIntoProject();

            const g = project.graphs.find(x => x.id === graphId);
            if (!g) return;

            currentGraphId = g.id;

            loadDataObject(g.data || { nodes: [], connections: [], metadata: { version: '3.2', created: new Date().toISOString(), nodeCounter: 0, attachOrderCounter: 0 } });

            if (g.view) {
                setViewImmediate(g.view.panX || 0, g.view.panY || 0, g.view.zoom || 1);
                markViewDirty();
            } else {
                resetView();
            }

            // restore history for this graph (in-memory)
            if (g.history && Array.isArray(g.history.undoStack) && g.history.undoStack.length) {
                undoStack = g.history.undoStack.slice();
                redoStack = (g.history.redoStack || []).slice();
            } else {
                initHistory();
                // store initial history for the graph
                g.history = { undoStack: undoStack.slice(), redoStack: redoStack.slice() };
            }

            setActivePane('graph');
            updateCrumbsForSelection({ kind: 'graph', id: g.id });
            updateSidebarSelectionHighlight('graph', g.id);
        }

        function setActivePane(which) {
            if (which === 'graph') {
                graphPane.classList.add('active');
                entityPane.classList.remove('active');
                // Recompute canvas size (sidebar may have changed)
                resizeCanvas();
                requestFrame();
            } else {
                entityPane.classList.add('active');
                graphPane.classList.remove('active');
            }
        }

        function updateCrumbsForSelection(sel) {
            if (!crumbsEl) return;
            if (!project) { crumbsEl.textContent = ''; return; }
            if (!sel) sel = project.ui.selection;
            if (!sel) return;

            if (sel.kind === 'folder') {
                const fsel = parseFolderSelection(sel);
                const category = fsel?.category || 'views';
                const folderId = fsel?.folderId || null;

                const base = category === 'views' ? ['Views']
                    : category === 'characters' ? ['Entities', 'Characters']
                        : category === 'items' ? ['Entities', 'Items']
                            : category === 'locations' ? ['Entities', 'Locations']
                                : category === 'variables' ? ['Entities', 'Variables']
                                    : category === 'docs' ? ['Documents']
                                        : ['Project'];

                const path = folderId ? folderPathNames(category, folderId) : [];
                crumbsEl.textContent = [...base, ...path].join(' ‚ñ∏ ');
                return;
            }

            if (sel.kind === 'graph') {
                const g = project.graphs.find(x => x.id === sel.id);
                crumbsEl.textContent = `Views ‚ñ∏ ${g ? g.name : 'Graph'}`;
                return;
            }

            const map = {
                character: ['Entities', 'Characters'],
                item: ['Entities', 'Items'],
                location: ['Entities', 'Locations'],
                variable: ['Entities', 'Variables'],
                note: ['Documents', 'Notes']
            };
            const [a, b] = map[sel.kind] || ['Entities', 'Item'];
            const ent = findEntity(sel.kind, sel.id);
            crumbsEl.textContent = `${a} ‚ñ∏ ${b} ‚ñ∏ ${ent ? ent.name : sel.kind}`;
        }

        function toggleExpanded(key) {
            project.ui.expanded[key] = !project.ui.expanded[key];
            renderSidebarTree();
            markUnsaved();
            scheduleLocalAutosave();
        }

        function findEntity(kind, id) {
            if (!project) return null;
            const bucket = kind === 'character' ? project.entities.characters
                : kind === 'item' ? project.entities.items
                    : kind === 'location' ? project.entities.locations
                        : kind === 'variable' ? project.entities.variables
                            : kind === 'note' ? project.entities.notes
                                : null;
            return bucket ? bucket.find(e => e.id === id) : null;
        }

        function selectInTree(kind, id) {
            if (!project) return;
            project.ui.selection = { kind, id };
            updateCrumbsForSelection(project.ui.selection);

            if (kind === 'graph') {
                project.ui.selectedGraphId = id;
                applyGraphFromProject(id);
            } else {
                openEntityEditor(kind, id);
            }

            // Don't rebuild the whole tree on single-click; it breaks double-click rename.
            updateSidebarSelectionHighlight(kind, id);
            scheduleLocalAutosave();
        }

        function updateSidebarSelectionHighlight(kind, id) {
            if (!sbTree) return;
            sbTree.querySelectorAll('.tree-row.selected').forEach(r => r.classList.remove('selected'));
            const row = sbTree.querySelector(`.tree-row[data-kind="${kind}"][data-id="${id}"]`);
            if (row) row.classList.add('selected');
        }


        function parseFolderSelection(sel) {
            if (!sel || sel.kind !== 'folder') return null;
            if (sel.category) return { category: sel.category, folderId: sel.folderId || null };
            // fallback parse from id: folder:category:folderIdOrRoot
            if (typeof sel.id === 'string' && sel.id.startsWith('folder:')) {
                const parts = sel.id.split(':');
                return { category: parts[1] || null, folderId: (parts[2] && parts[2] !== 'root') ? parts[2] : null };
            }
            return null;
        }

        function toggleNavFolderExpanded(category, folderId) {
            if (!project) return;
            const key = navExpandKey(category, folderId);
            project.ui.expanded[key] = !project.ui.expanded[key];
            renderSidebarTree();
            scheduleLocalAutosave();
        }

        function ensureCategoryExpanded(category, parentFolderId) {
            if (!project) return;

            // Make sure top-level containers are open
            if (category === 'characters' || category === 'items' || category === 'locations') {
                project.ui.expanded.entities = true;
            }

            if (parentFolderId) {
                project.ui.expanded[navExpandKey(category, parentFolderId)] = true;
                return;
            }

            // root category expanded keys
            if (category === 'views') project.ui.expanded.views = true;
            if (category === 'characters') project.ui.expanded.characters = true;
            if (category === 'items') project.ui.expanded.items = true;
            if (category === 'locations') project.ui.expanded.locations = true;
            if (category === 'docs') project.ui.expanded.docs = true;
        }

        function parentFolderForCategory(category) {
            const sel = project?.ui?.selection;
            if (!sel) return null;

            // If a folder is selected in this category, create inside it
            const fsel = parseFolderSelection(sel);
            if (fsel && fsel.category === category) return fsel.folderId || null;

            // If a leaf in this category is selected, create next to it (same parent folder)
            const leafKind = sel.kind;
            if (categoryForKind(leafKind) === category) {
                const leaf = navFindLeafByRef(category, leafKind, sel.id);
                return leaf ? (leaf.parentId || null) : null;
            }

            return null;
        }

        function defaultCategoryForAdd(type) {
            if (type === 'graph') return 'views';
            if (type === 'character') return 'characters';
            if (type === 'item') return 'items';
            if (type === 'location') return 'locations';
            if (type === 'variable') return 'variables';
            if (type === 'note') return 'docs';
            return 'views';
        }

        function getSidebarCreateContext(type) {
            const defCat = defaultCategoryForAdd(type);
            const sel = project?.ui?.selection || null;
            if (!sel) return { category: defCat, parentId: null };

            const fsel = parseFolderSelection(sel);
            if (fsel) return { category: fsel.category || defCat, parentId: fsel.folderId || null };

            const found = navFindLeafAnywhere(sel.kind, sel.id);
            if (found) return { category: found.category || defCat, parentId: found.node.parentId || null };

            return { category: defCat, parentId: null };
        }

        function addNewSidebarItem(type) {
            if (!project) return;
            ensureNav(project);

            const ctx = getSidebarCreateContext(type);

            // Folder
            if (type === 'folder') {
                const folder = { id: uid('navf'), parentId: ctx.parentId || null, kind: 'folder', name: 'New Folder' };
                project.nav[ctx.category].push(folder);
                ensureCategoryExpanded(ctx.category, ctx.parentId);
                project.ui.expanded[navExpandKey(ctx.category, folder.id)] = true;

                renderSidebarTree();
                selectFolder(ctx.category, folder.id, { skipAutosave: true });

                markUnsaved();
                commitProjectHistory();
                scheduleLocalAutosave();
                return;
            }

            // Graph
            if (type === 'graph') {
                persistCurrentGraphIntoProject();
                const g = makeEmptyGraph(`Graph ${project.graphs.length + 1}`);
                project.graphs.push(g);

                // leaf goes where you currently are (any folder/category)
                project.nav[ctx.category].push({ id: uid('nav'), parentId: ctx.parentId || null, kind: 'leaf', refKind: 'graph', refId: g.id });
                ensureCategoryExpanded(ctx.category, ctx.parentId);

                renderSidebarTree();
                project.ui.selectedGraphId = g.id;
                selectInTree('graph', g.id);

                initHistory();
                markUnsaved();
                commitProjectHistory();
                scheduleLocalAutosave();
                return;
            }

            // Entities / Notes
            if (type === 'character' || type === 'item' || type === 'location' || type === 'variable' || type === 'note') {
                const bucket =
                    type === 'character' ? project.entities.characters :
                        type === 'item' ? project.entities.items :
                            type === 'location' ? project.entities.locations :
                                type === 'variable' ? project.entities.variables :
                                    project.entities.notes;

                const labelBase =
                    type === 'character' ? 'Character' :
                        type === 'item' ? 'Item' :
                            type === 'location' ? 'Location' :
                                type === 'variable' ? 'Variable' :
                                    'Note';

                const e = makeEntity(type, `${labelBase} ${bucket.length + 1}`);
                bucket.push(e);

                // leaf goes where you currently are (any folder/category)
                project.nav[ctx.category].push({ id: uid('nav'), parentId: ctx.parentId || null, kind: 'leaf', refKind: type, refId: e.id });
                ensureCategoryExpanded(ctx.category, ctx.parentId);

                renderSidebarTree();
                selectInTree(type, e.id);

                markUnsaved();
                commitProjectHistory();
                scheduleLocalAutosave();
                return;
            }
        }

        function startRenameLeaf(rowEl, kind, id) {
            if (!rowEl) return;
            const nameEl = rowEl.querySelector('.tree-name');
            if (!nameEl) return;

            let current = nameEl.textContent;
            if (kind === 'variable') {
                const ent = findEntity(kind, id);
                if (ent?.name) current = ent.name;
            }
            const input = document.createElement('input');
            input.className = 'tree-rename';
            input.value = current;

            nameEl.replaceWith(input);
            input.focus();
            input.select();

            const commit = () => {
                const next = (input.value || '').trim() || current;
                const changed = next !== current;
                if (kind === 'graph') {
                    const g = project.graphs.find(x => x.id === id);
                    if (g) g.name = next;
                } else {
                    const ent = findEntity(kind, id);
                    if (ent) {
                        ent.name = next;
                        if (kind === 'character') {
                            propagateCharacterRename(id, next);
                        }
                        // Keep the editor in sync if this entity is currently open
                        if (project?.ui?.selection?.kind === kind && project.ui.selection.id === id) {
                            if (entName) entName.value = ent.name || '';
                        }
                    }
                }
                renderSidebarTree();
                if (project?.ui?.selection) updateSidebarSelectionHighlight(project.ui.selection.kind, project.ui.selection.id);
                updateCrumbsForSelection(project.ui.selection);
                if (changed) {
                    markUnsaved();
                    commitProjectHistory();
                }
                scheduleLocalAutosave();
            };

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); commit(); }
                if (e.key === 'Escape') { e.preventDefault(); renderSidebarTree(); if (project?.ui?.selection) updateSidebarSelectionHighlight(project.ui.selection.kind, project.ui.selection.id); }
            });
            input.addEventListener('blur', commit);
        }

        function startRenameFolder(rowEl, category, folderId) {
            if (!rowEl || !project) return;
            const nameEl = rowEl.querySelector('.tree-name');
            if (!nameEl) return;

            const current = nameEl.textContent;
            const input = document.createElement('input');
            input.className = 'tree-rename';
            input.value = current;

            nameEl.replaceWith(input);
            input.focus();
            input.select();

            const commit = () => {
                const next = (input.value || '').trim() || current;
                const changed = next !== current;
                const f = navGet(category, folderId);
                if (f && f.kind === 'folder') f.name = next;
                renderSidebarTree();
                if (project?.ui?.selection) updateSidebarSelectionHighlight(project.ui.selection.kind, project.ui.selection.id);
                updateCrumbsForSelection(project.ui.selection);
                if (changed) {
                    markUnsaved();
                    commitProjectHistory();
                }
                scheduleLocalAutosave();
            };

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); commit(); }
                if (e.key === 'Escape') { e.preventDefault(); renderSidebarTree(); if (project?.ui?.selection) updateSidebarSelectionHighlight(project.ui.selection.kind, project.ui.selection.id); }
            });
            input.addEventListener('blur', commit);
        }

        function treeRow({ label, icon, depth = 0, isFolder = false, expanded = false, selected = false, onClick, onTwist, onRename }) {
            const row = document.createElement('div');
            row.className = 'tree-row' + (selected ? ' selected' : '');
            row.style.paddingLeft = (8 + depth * 12) + 'px';

            const twist = document.createElement('button');
            twist.className = 'tree-twist' + (isFolder ? '' : ' spacer');
            twist.textContent = isFolder ? (expanded ? '‚ñæ' : '‚ñ∏') : '‚ñ∏';
            twist.addEventListener('click', (e) => { e.stopPropagation(); onTwist && onTwist(); });

            const ic = document.createElement('span');
            ic.className = 'tree-icon';
            ic.textContent = icon || '‚Ä¢';

            const name = document.createElement('span');
            name.className = 'tree-name';
            name.textContent = label;

            row.appendChild(twist);
            row.appendChild(ic);
            row.appendChild(name);

            row.addEventListener('click', (e) => { e.stopPropagation(); onClick && onClick(); });
            row.addEventListener('dblclick', (e) => { e.stopPropagation(); onRename && onRename(row); });

            return row;
        }

        function renderSidebarTree() {
            if (!sbTree || !project) return;

            ensureNav(project);

            const q = (sbSearch?.value || '').trim().toLowerCase();
            const sel = project.ui.selection || { kind: 'graph', id: project.ui.selectedGraphId };

            sbTree.innerHTML = '';

            const matchesNode = (category, node) => {
                if (!q) return true;
                if (!node) return false;
                if (node.kind === 'folder') {
                    const nm = (node.name || 'folder').toLowerCase();
                    if (nm.includes(q)) return true;
                    const kids = navChildren(category, node.id);
                    return kids.some(ch => matchesNode(category, ch));
                }
                if (node.kind === 'leaf') {
                    const label = (labelForLeaf(node.refKind, node.refId) || '').toLowerCase();
                    return label.includes(q);
                }
                return false;
            };

            const renderNav = (wrap, category, parentId, depth) => {
                const kids = navChildren(category, parentId).filter(n => matchesNode(category, n));
                for (const n of kids) {
                    if (n.kind === 'folder') {
                        const expKey = navExpandKey(category, n.id);
                        const expanded = !!project.ui.expanded[expKey];
                        const selected = sel.kind === 'folder' && sel.id === folderSelId(category, n.id);

                        const row = treeRow({
                            label: n.name || 'Folder',
                            icon: 'üìÅ',
                            depth,
                            isFolder: true,
                            expanded,
                            selected,
                            onClick: () => { selectFolder(category, n.id); },
                            onTwist: () => { toggleNavFolderExpanded(category, n.id); },
                            onRename: (rowEl) => startRenameFolder(rowEl, category, n.id)
                        });
                        row.dataset.kind = 'folder';
                        row.dataset.id = folderSelId(category, n.id);
                        wireSidebarDnD(row, { type: 'folder', category, folderId: n.id, oldParentId: n.parentId || null });
                        wrap.appendChild(row);

                        if (expanded) {
                            const childWrap = document.createElement('div');
                            childWrap.className = 'tree-children';
                            wrap.appendChild(childWrap);
                            renderNav(childWrap, category, n.id, depth + 1);
                        }
                    } else if (n.kind === 'leaf') {
                        const refKind = n.refKind;
                        const refId = n.refId;
                        const label = labelForLeaf(refKind, refId);
                        const icon = refKind === 'graph' ? 'üß†'
                            : refKind === 'character' ? 'üë§'
                                : refKind === 'item' ? 'üéí'
                                    : refKind === 'location' ? 'üìç'
                                        : refKind === 'variable' ? 'üíé'
                                            : 'üìù';

                        const selected = sel.kind === refKind && sel.id === refId;
                        let displayLabel = label;
                        if (refKind === 'variable') {
                            const curVal = getVariableValue(label);
                            displayLabel = `${label}: ${curVal}`;
                        }

                        const row = treeRow({
                            label: displayLabel,
                            icon,
                            depth,
                            isFolder: false,
                            selected,
                            onClick: () => { selectInTree(refKind, refId); },
                            onRename: (rowEl) => startRenameLeaf(rowEl, refKind, refId)
                        });

                        if (refKind === 'variable') {
                            row.style.cursor = 'pointer';
                            const valSpan = row.querySelector('.tree-name');
                            valSpan.title = 'Click to override runtime value';
                            valSpan.style.color = '#fff';
                            valSpan.innerHTML = `<span style="color:var(--text-secondary)">${label}:</span> <span style="color:#27ae60; font-weight:bold;">${getVariableValue(label)}</span>`;

                            valSpan.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                const newVal = prompt(`Override runtime value for "${label}":`, getVariableValue(label));
                                if (newVal !== null) {
                                    setVariableValue(label, newVal);
                                    renderSidebarTree();
                                }
                            });
                        }

                        row.dataset.kind = refKind;
                        row.dataset.id = refId;
                        wireSidebarDnD(row, { type: 'leaf', category, refKind, refId, parentId: n.parentId || null, navId: n.id });
                        wrap.appendChild(row);
                    }
                }
            };

            // Root: Views
            const viewsRow = treeRow({
                label: 'Views',
                icon: 'üó∫Ô∏è',
                depth: 0,
                isFolder: true,
                expanded: !!project.ui.expanded.views,
                selected: sel.kind === 'folder' && sel.id === folderSelId('views', null),
                onClick: () => { selectFolder('views', null); },
                onTwist: () => toggleExpanded('views')
            });
            viewsRow.dataset.kind = 'folder';
            viewsRow.dataset.id = folderSelId('views', null);
            wireSidebarDnD(viewsRow, { type: 'root', category: 'views', folderId: null });
            sbTree.appendChild(viewsRow);

            if (project.ui.expanded.views) {
                const w = document.createElement('div');
                w.className = 'tree-children';
                sbTree.appendChild(w);
                renderNav(w, 'views', null, 1);
            }

            // Root: Entities
            const entRow = treeRow({
                label: 'Entities',
                icon: 'üß©',
                depth: 0,
                isFolder: true,
                expanded: !!project.ui.expanded.entities,
                selected: false,
                onClick: () => { },
                onTwist: () => toggleExpanded('entities')
            });
            entRow.dataset.kind = 'folder';
            entRow.dataset.id = 'folder:entities:root';
            sbTree.appendChild(entRow);

            if (project.ui.expanded.entities) {
                const w = document.createElement('div');
                w.className = 'tree-children';
                sbTree.appendChild(w);

                const addCategoryFolder = (label, icon, key, category) => {
                    const row = treeRow({
                        label,
                        icon,
                        depth: 1,
                        isFolder: true,
                        expanded: !!project.ui.expanded[key],
                        selected: sel.kind === 'folder' && sel.id === folderSelId(category, null),
                        onClick: () => { selectFolder(category, null); },
                        onTwist: () => toggleExpanded(key)
                    });
                    row.dataset.kind = 'folder';
                    row.dataset.id = folderSelId(category, null);
                    wireSidebarDnD(row, { type: 'root', category, folderId: null });
                    w.appendChild(row);

                    if (project.ui.expanded[key]) {
                        const ww = document.createElement('div');
                        ww.className = 'tree-children';
                        w.appendChild(ww);
                        renderNav(ww, category, null, 2);
                    }
                };

                addCategoryFolder('Characters', 'üë§', 'characters', 'characters');
                addCategoryFolder('Items', 'üéí', 'items', 'items');
                addCategoryFolder('Locations', 'üìç', 'locations', 'locations');
                addCategoryFolder('Variables', 'üíé', 'variables', 'variables');
            }

            // Root: Documents
            const docsRow = treeRow({
                label: 'Documents',
                icon: 'üìÑ',
                depth: 0,
                isFolder: true,
                expanded: !!project.ui.expanded.docs,
                selected: sel.kind === 'folder' && sel.id === folderSelId('docs', null),
                onClick: () => { selectFolder('docs', null); },
                onTwist: () => toggleExpanded('docs')
            });
            docsRow.dataset.kind = 'folder';
            docsRow.dataset.id = folderSelId('docs', null);
            wireSidebarDnD(docsRow, { type: 'root', category: 'docs', folderId: null });
            sbTree.appendChild(docsRow);

            if (project.ui.expanded.docs) {
                const w = document.createElement('div');
                w.className = 'tree-children';
                sbTree.appendChild(w);
                renderNav(w, 'docs', null, 1);
            }
        }

        let sidebarDrag = null;
        let sidebarDropEl = null;

        function clearDropEl() {
            if (!sidebarDropEl) return;
            sidebarDropEl.classList.remove('drop-target', 'drop-deny');
            sidebarDropEl = null;
        }

        function wireSidebarDnD(row, info) {
            if (!row) return;

            // droppable
            row.addEventListener('dragover', (ev) => {
                if (!sidebarDrag) return;

                const destCategory = info.category;
                let destParentId = null;

                if (info.type === 'folder') destParentId = info.folderId;
                else if (info.type === 'leaf') destParentId = info.parentId ?? null;
                else if (info.type === 'root') destParentId = null;

                let allow = true;
                if (sidebarDrag.kind === 'folder' && sidebarDrag.srcCategory === destCategory) {
                    if (navIsDescendant(destCategory, sidebarDrag.folderId, destParentId)) allow = false;
                }

                clearDropEl();
                sidebarDropEl = row;
                row.classList.add(allow ? 'drop-target' : 'drop-deny');

                if (allow) ev.preventDefault();
            });

            row.addEventListener('drop', (ev) => {
                if (!sidebarDrag) return;
                ev.preventDefault();
                clearDropEl();

                const destCategory = info.category;
                let destParentId = null;

                if (info.type === 'folder') destParentId = info.folderId;
                else if (info.type === 'leaf') destParentId = info.parentId ?? null;
                else if (info.type === 'root') destParentId = null;

                // no-op?
                if (sidebarDrag.kind === 'leaf') {
                    if (sidebarDrag.srcCategory === destCategory && sidebarDrag.parentId === (destParentId || null)) return;
                } else {
                    if (sidebarDrag.srcCategory === destCategory && sidebarDrag.oldParentId === (destParentId || null)) return;
                    if (sidebarDrag.srcCategory === destCategory && navIsDescendant(destCategory, sidebarDrag.folderId, destParentId)) return;
                }

                // move
                persistCurrentGraphIntoProject();

                if (sidebarDrag.kind === 'leaf') {
                    const srcArr = project.nav[sidebarDrag.srcCategory] || [];
                    const idx = srcArr.findIndex(n => n && n.id === sidebarDrag.navId);
                    if (idx < 0) return;
                    const node = srcArr[idx];

                    // remove from src
                    project.nav[sidebarDrag.srcCategory] = srcArr.filter(n => n && n.id !== sidebarDrag.navId);

                    node.parentId = destParentId || null;

                    // push into dest
                    project.nav[destCategory].push(node);
                } else {
                    const subtree = navCollectSubtreeIds(sidebarDrag.srcCategory, sidebarDrag.folderId);
                    const srcArr = project.nav[sidebarDrag.srcCategory] || [];
                    const moving = srcArr.filter(n => n && subtree.has(n.id));
                    const staying = srcArr.filter(n => n && !subtree.has(n.id));
                    project.nav[sidebarDrag.srcCategory] = staying;

                    // update root folder parent
                    const root = moving.find(n => n && n.id === sidebarDrag.folderId);
                    if (root) root.parentId = destParentId || null;

                    // move all to dest category
                    project.nav[destCategory].push(...moving);

                    // if that folder was selected, update selection‚Äôs category
                    if (project.ui.selection?.kind === 'folder') {
                        const fsel = parseFolderSelection(project.ui.selection);
                        if (fsel?.folderId === sidebarDrag.folderId) {
                            selectFolder(destCategory, sidebarDrag.folderId, { skipAutosave: true });
                        }
                    }
                }

                ensureCategoryExpanded(destCategory, destParentId);
                renderSidebarTree();
                markUnsaved();
                commitProjectHistory();
                scheduleLocalAutosave();
            });

            // draggable (folders + leaves)
            if (info.type === 'folder' || info.type === 'leaf') {
                row.draggable = true;

                row.addEventListener('dragstart', (ev) => {
                    lastFocusArea = 'sidebar';
                    clearDropEl();
                    row.classList.add('dragging');

                    if (info.type === 'folder') {
                        sidebarDrag = {
                            kind: 'folder',
                            srcCategory: info.category,
                            folderId: info.folderId,
                            oldParentId: info.oldParentId ?? null
                        };
                    } else {
                        sidebarDrag = {
                            kind: 'leaf',
                            srcCategory: info.category,
                            navId: info.navId,
                            parentId: info.parentId ?? null
                        };
                    }

                    ev.dataTransfer?.setData('text/plain', 'move');
                    if (ev.dataTransfer) ev.dataTransfer.effectAllowed = 'move';
                });

                row.addEventListener('dragend', () => {
                    row.classList.remove('dragging');
                    sidebarDrag = null;
                    clearDropEl();
                });
            }
        }

        function deleteSidebarSelection() {
            const sel = project?.ui?.selection;
            if (!sel) return;

            // Folder delete
            if (sel.kind === 'folder') {
                const fsel = parseFolderSelection(sel);
                if (!fsel) return;

                // don't delete category roots (folderId null)
                if (!fsel.folderId) return;

                const folderNode = navGet(fsel.category, fsel.folderId);
                const name = folderNode?.name || 'Folder';
                const subtree = navCollectSubtreeIds(fsel.category, fsel.folderId);

                const hasKids = subtree.size > 1;
                const ok = confirm(`Delete "${name}"${hasKids ? " and everything inside it" : ""}?`);
                if (!ok) return;

                // remove nav nodes
                project.nav[fsel.category] = navList(fsel.category).filter(n => !subtree.has(n.id));

                // after removing tree nodes, just prune invalid leaves / re-add missing ones
                ensureNav(project);

                renderSidebarTree();
                // bounce to graph
                const gid = project.ui.selectedGraphId || project.graphs[0]?.id;
                if (gid) selectInTree('graph', gid);

                markUnsaved();
                commitProjectHistory();
                scheduleLocalAutosave();
                return;
            }

            // Leaf delete (graph/entity/note)
            const kind = sel.kind;
            const id = sel.id;

            if (!kind || !id) return;

            if (kind === 'graph') {
                const g = project.graphs.find(x => x.id === id);
                const ok = confirm(`Delete graph "${g?.name || 'Graph'}"?`);
                if (!ok) return;

                // remove all leaves pointing to this graph (any category)
                for (const c of ['views', 'characters', 'items', 'locations', 'variables', 'docs']) {
                    project.nav[c] = navList(c).filter(n => !(n.kind === 'leaf' && n.refKind === 'graph' && n.refId === id));
                }

                // remove the graph itself
                project.graphs = project.graphs.filter(x => x.id !== id);

                // pick a new current graph if needed
                const nextId = project.graphs[0]?.id || null;
                project.ui.selectedGraphId = nextId;
                project.ui.selection = nextId ? { kind: 'graph', id: nextId } : null;

                if (nextId) applyGraphFromProject(nextId, { skipPersist: true });
                renderSidebarTree();
                if (nextId) selectInTree('graph', nextId);

                markUnsaved();
                commitProjectHistory();
                scheduleLocalAutosave();
                return;
            }

            const leafLabel = labelForLeaf(kind, id);
            const ok = confirm(`Delete "${leafLabel}"?`);
            if (!ok) return;

            // entities/notes: remove leaves anywhere
            for (const c of ['views', 'characters', 'items', 'locations', 'variables', 'docs']) {
                project.nav[c] = navList(c).filter(n => !(n.kind === 'leaf' && n.refKind === kind && n.refId === id));
            }

            const bucket =
                kind === 'character' ? project.entities.characters :
                    kind === 'item' ? project.entities.items :
                        kind === 'location' ? project.entities.locations :
                            kind === 'variable' ? project.entities.variables :
                                kind === 'note' ? project.entities.notes :
                                    null;

            if (bucket) {
                const idx = bucket.findIndex(x => x.id === id);
                if (idx >= 0) bucket.splice(idx, 1);
            }

            ensureNav(project);
            renderSidebarTree();

            // bounce back to graph
            const gid = project.ui.selectedGraphId || project.graphs[0]?.id;
            if (gid) selectInTree('graph', gid);

            markUnsaved();
            commitProjectHistory();
            scheduleLocalAutosave();
        }



        function openEntityEditor(kind, id) {
            const ent = findEntity(kind, id);
            if (!ent) return;

            editingEntityRef = { kind, id };
            entityKindEl.textContent = kind === 'character' ? 'Character'
                : kind === 'item' ? 'Item'
                    : kind === 'location' ? 'Location'
                        : kind === 'variable' ? 'Variable'
                            : 'Note';

            const isVar = kind === 'variable';
            const isNote = kind === 'note';

            document.getElementById('rowTech').style.display = (isVar || isNote) ? 'none' : '';
            document.getElementById('rowObjId').style.display = (isVar || isNote) ? 'none' : '';
            document.getElementById('rowHalf').style.display = (isVar || isNote) ? 'none' : 'grid';
            document.getElementById('rowVarType').style.display = isVar ? '' : 'none';
            document.getElementById('rowVarValue').style.display = isVar ? '' : 'none';

            entName.value = ent.name || '';
            entTech.value = ent.technical || '';
            entObjectId.value = ent.objectId || '';
            entQty.value = ent.quantity || 0;
            entTags.value = Array.isArray(ent.tags) ? ent.tags.join(', ') : '';
            entDesc.value = ent.description || '';
            entCode.value = ent.code || '';

            if (isVar) {
                document.getElementById('entVarType').value = ent.varType || 'boolean';
                document.getElementById('entVarValue').value = ent.initialValue || '';

                document.getElementById('rowRuntimeValue').style.display = '';
                document.getElementById('entRuntimeValue').value = getVariableValue(ent.name);
            } else {
                document.getElementById('rowRuntimeValue').style.display = 'none';
            }

            setActivePane('entity');
            updateCrumbsForSelection({ kind, id });
            updateSidebarSelectionHighlight(kind, id);
        }


        function getCharacterNameById(id) {
            if (!id || !project || !project.entities || !Array.isArray(project.entities.characters)) return null;
            return project.entities.characters.find(c => c.id === id)?.name || null;
        }

        function syncCharacterLabels() {
            // Update visible speaker tags without re-rendering nodes (keeps text editing stable)
            document.querySelectorAll('.line-speaker[data-speaker-id]').forEach(sp => {
                const id = sp.dataset.speakerId;
                if (!id) return;
                const name = getCharacterNameById(id);
                if (name && sp.textContent !== name) sp.textContent = name;
            });
        }

        function propagateCharacterRename(charId, newName) {
            if (!project || !charId || !newName) return;

            // Ensure current graph edits are persisted before we touch graph data
            persistCurrentGraphIntoProject();

            // Update all graphs' stored data
            for (const g of (project.graphs || [])) {
                const d = g.data;
                if (!d || !Array.isArray(d.nodes)) continue;
                for (const n of d.nodes) {
                    if (n.type !== 'character' || !Array.isArray(n.lines)) continue;
                    for (const ln of n.lines) {
                        if (ln && ln.speakerId === charId) ln.speaker = newName;
                    }
                }
            }

            // Update live nodes in current graph
            for (const n of nodes) {
                if (n.type !== 'character' || !Array.isArray(n.lines)) continue;
                let touched = false;
                for (const ln of n.lines) {
                    if (ln && ln.speakerId === charId) {
                        ln.speaker = newName;
                        touched = true;
                    }
                }
                if (touched) {
                    // update DOM labels only
                    syncCharacterLabels();
                }
            }

            persistCurrentGraphIntoProject();
        }

        function bindEntityEditor() {
            const onChange = () => {
                if (!editingEntityRef) return;
                const ent = findEntity(editingEntityRef.kind, editingEntityRef.id);
                if (!ent) return;

                ent.name = entName.value.trim() || ent.name;
                ent.technical = entTech.value.trim();
                ent.objectId = entObjectId.value.trim();
                const qtyVal = parseInt(entQty.value, 10);
                ent.quantity = Number.isFinite(qtyVal) ? qtyVal : ent.quantity;
                ent.tags = (entTags.value || '').split(',').map(s => s.trim()).filter(Boolean);
                ent.description = entDesc.value;
                ent.code = entCode.value;

                if (ent.kind === 'variable') {
                    ent.varType = document.getElementById('entVarType').value;
                    ent.initialValue = document.getElementById('entVarValue').value;
                }
                if (editingEntityRef.kind === 'character') {
                    propagateCharacterRename(editingEntityRef.id, ent.name);
                }

                updateCrumbsForSelection(project.ui.selection);
                renderSidebarTree();
                scheduleLocalAutosave();
            };

            const inputs = [
                entName, entTech, entObjectId, entQty, entTags, entDesc, entCode,
                document.getElementById('entVarType'),
                document.getElementById('entVarValue'),
                document.getElementById('entRuntimeValue')
            ];
            inputs.forEach(el => {
                if (!el) return;
                el.addEventListener('input', debounce((e) => {
                    if (e.target.id === 'entRuntimeValue') {
                        if (editingEntityRef?.kind === 'variable') {
                            const ent = findEntity('variable', editingEntityRef.id);
                            if (ent) setVariableValue(ent.name, e.target.value);
                        }
                    } else {
                        onChange();
                    }
                }, 180));
            });

            document.getElementById('btnResetVar').addEventListener('click', () => {
                if (editingEntityRef?.kind === 'variable') {
                    const ent = findEntity('variable', editingEntityRef.id);
                    if (ent) {
                        setVariableValue(ent.name, ent.initialValue);
                        document.getElementById('entRuntimeValue').value = getVariableValue(ent.name);
                    }
                }
            });

            entityBackBtn.addEventListener('click', () => {
                // Go back to currently selected graph
                const gid = project.ui.selectedGraphId || project.graphs[0]?.id;
                if (gid) selectInTree('graph', gid);
            });

            entityDeleteBtn.addEventListener('click', () => {
                if (!editingEntityRef) return;
                const { kind, id } = editingEntityRef;
                const ok = confirm('Delete this item?');
                if (!ok) return;

                const bucket = kind === 'character' ? project.entities.characters
                    : kind === 'item' ? project.entities.items
                        : kind === 'location' ? project.entities.locations
                            : kind === 'variable' ? project.entities.variables
                                : kind === 'note' ? project.entities.notes
                                    : null;

                if (bucket) {
                    const idx = bucket.findIndex(e => e.id === id);
                    if (idx >= 0) bucket.splice(idx, 1);
                }

                for (const c of ['views', 'characters', 'items', 'locations', 'variables', 'docs']) {
                    project.nav[c] = navList(c).filter(n => !(n.kind === 'leaf' && n.refKind === kind && n.refId === id));
                }
                ensureNav(project);
                editingEntityRef = null;

                markUnsaved();
                commitProjectHistory();
                renderSidebarTree();

                // Return to graph
                const gid = project.ui.selectedGraphId || project.graphs[0]?.id;
                if (gid) selectInTree('graph', gid);
                scheduleLocalAutosave();
            });
        }

        function initSidebarInteractions() {
            // Collapse / expand
            sbToggle.addEventListener('click', () => {
                project.ui.sidebarCollapsed = !project.ui.sidebarCollapsed;
                if (project.ui.sidebarCollapsed) {
                    lastSidebarWidth = project.ui.sidebarWidth || lastSidebarWidth;
                    sidebar.classList.add('collapsed');
                } else {
                    sidebar.classList.remove('collapsed');
                    applySidebarWidth(project.ui.sidebarWidth || lastSidebarWidth);
                }
                scheduleLocalAutosave();
                // Graph needs resize update
                if (isGraphActivePane()) resizeCanvas();
            });

            // Resize
            let resizing = false;
            let startX = 0;
            let startW = 0;

            const onMove = (e) => {
                if (!resizing) return;
                const dx = (e.clientX - startX);
                const w = Math.max(200, Math.min(560, startW + dx));
                applySidebarWidth(w);
            };
            const stop = () => {
                if (!resizing) return;
                resizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                scheduleLocalAutosave();
                if (isGraphActivePane()) resizeCanvas();
            };

            sbResizer.addEventListener('pointerdown', (e) => {
                if (project.ui.sidebarCollapsed) return;
                resizing = true;
                startX = e.clientX;
                startW = sidebar.getBoundingClientRect().width;
                sbResizer.setPointerCapture?.(e.pointerId);
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            window.addEventListener('pointermove', onMove);
            window.addEventListener('pointerup', stop);

            // Search
            sbSearch.addEventListener('input', debounce(renderSidebarTree, 80));
            // Footer Add menu (folders + files)
            if (sbAddBtn && sbAddMenu) {
                sbAddBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    sbAddMenu.hidden = !sbAddMenu.hidden;
                });

                sbAddMenu.addEventListener('click', (e) => {
                    const btn = e.target.closest('.sb-menu-item[data-add]');
                    if (!btn) return;
                    e.stopPropagation();
                    const type = btn.getAttribute('data-add');
                    addNewSidebarItem(type);
                    sbAddMenu.hidden = true;
                });

                sbDeleteBtn?.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    lastFocusArea = 'sidebar';
                    deleteSidebarSelection();
                });

                window.addEventListener('pointerdown', (e) => {
                    if (!sbAddMenu || sbAddMenu.hidden) return;
                    if (sbAddMenu.contains(e.target) || sbAddBtn.contains(e.target)) return;
                    sbAddMenu.hidden = true;
                });
            }

            mhGoGraph.addEventListener('click', () => {
                const gid = project.ui.selectedGraphId || project.graphs[0]?.id;
                if (gid) selectInTree('graph', gid);
            });

            mhAddNode.addEventListener('click', () => {
                if (!isGraphActivePane()) {
                    const gid = project.ui.selectedGraphId || project.graphs[0]?.id;
                    if (gid) selectInTree('graph', gid);
                }
                // Add near center of current viewport
                const rect = canvasContainer.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                const wpos = screenToWorld(cx, cy);
                const n = addNode(wpos.x - 120, wpos.y - 80);
                selectNode(n);
                commitHistory();
                markDrawDirty();
            });

            // Variable picker UI handlers - build condition from dropdowns
            
            // --- Connection Conditions (multi) ---
            const addConnBtn = document.getElementById('addConnConditionBtn');
            const logicSel = document.getElementById('connLogic');
            const condArea = document.getElementById('connCondition');

            if (addConnBtn) {
                addConnBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!selectedConnection) return;
                    ensureConnectionConditionModel(selectedConnection);
                    selectedConnection.conditions.push({ varName: '', operator: '>=', value: '' });
                    renderConnectionConditionsUI();
                    markUnsaved();
                });
            }

            if (logicSel) {
                logicSel.addEventListener('change', () => {
                    if (!selectedConnection) return;
                    ensureConnectionConditionModel(selectedConnection);
                    selectedConnection.conditionLogic = logicSel.value || 'AND';
                    const gen = buildExpressionFromConditions(selectedConnection.conditions || [], selectedConnection.conditionLogic);
                    selectedConnection.condition = gen;
                    if (condArea) condArea.value = gen;
                    updateConditionPreview();
                    markUnsaved();
                    markDrawDirty();
                });
            }

            // Manual condition textarea (supports multiple: "and/or", "&&/||", and {{var}} tokens, and => as >=)
            if (condArea) {
                condArea.addEventListener('input', debounce((e) => {
                    if (!selectedConnection) return;
                    selectedConnection.condition = e.target.value;
                    updateConditionPreview();
                    markUnsaved();
                    markDrawDirty();
                }, 150));

                condArea.addEventListener('blur', () => {
                    if (!selectedConnection) return;
                    // Try to convert simple manual expressions into the row UI
                    const parsed = tryParseFlatConditionsFromExpression(selectedConnection.condition || '');
                    if (!parsed) return; // complex expressions stay manual-only
                    selectedConnection.conditionLogic = parsed.logic || 'AND';
                    selectedConnection.conditions = parsed.conditions.length ? parsed.conditions : [{ varName: '', operator: '>=', value: '' }];
                    renderConnectionConditionsUI();
                    updateConditionPreview();
                    markUnsaved();
                    markDrawDirty();
                });
            }

// Set variable handlers
            document.getElementById('connSetVar').addEventListener('change', (e) => {
                if (selectedConnection) {
                    selectedConnection.setVar = e.target.value;
                    markUnsaved();
                }
            });

            document.getElementById('connSetValue').addEventListener('input', debounce((e) => {
                if (selectedConnection) {
                    selectedConnection.setValue = e.target.value;
                    markUnsaved();
                }
            }, 150));

            document.getElementById('deleteConnBtn').addEventListener('click', () => {
                if (selectedConnection) {
                    const ok = confirm('Delete this connection?');
                    if (!ok) return;
                    connections = connections.filter(c => c !== selectedConnection);
                    selectedConnection = null;
                    updateConnectionUI();
                    updateConnectionVisuals();
                    markUnsaved();
                    markDrawDirty();
                    commitHistory();
                }
            });

            document.getElementById('traverseConnBtn').addEventListener('click', () => {
                if (!selectedConnection) return;

                // Respect conditions during simulation
                const expr = (selectedConnection.condition && String(selectedConnection.condition).trim())
                    ? selectedConnection.condition
                    : buildExpressionFromConditions(selectedConnection.conditions || [], selectedConnection.conditionLogic || 'AND');

                const evalResult = expr ? evaluateCondition(expr) : { passes: true, hasCondition: false };

                if (evalResult.hasCondition && !evalResult.passes) {
                    // Block traversal if requirements fail
                    updateConditionPreview();
                    return;
                }

                executeConnectionAction(selectedConnection);

                // Enter the target node as part of traversal simulation
                const toNode = nodes.find(n => n.id === selectedConnection.to.nodeId);
                if (toNode) {
                    executeNodeEnterActions(toNode);
                    selectNode(toNode);
                }

                updateConditionPreview(); // Badge and preview update
                updateConnectionUI();      // Refresh local panel
                updateNodeActionsUI();
            });

            
            // Node action controls
            const addNodeBtn = document.getElementById('addNodeActionBtn');
            const simNodeBtn = document.getElementById('simulateEnterNodeBtn');

            if (addNodeBtn) {
                addNodeBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!selectedNode) return;
                    ensureNodeEnterActions(selectedNode);
                    selectedNode.onEnterActions.push({ varName: '', mode: 'set', value: '' });
                    updateNodeActionsUI();
                    markUnsaved();
                });
            }

            if (simNodeBtn) {
                simNodeBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!selectedNode) return;
                    executeNodeEnterActions(selectedNode);
                    updateConditionPreview();
                    updateNodeActionsUI();
                    markUnsaved();
                });
            }

// Quick key: Esc returns to graph
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && !isEditableElement(document.activeElement)) {
                    const gid = project?.ui?.selectedGraphId || project?.graphs?.[0]?.id;
                    if (gid) selectInTree('graph', gid);
                }
            });
        }

        function applySidebarWidth(w) {
            project.ui.sidebarWidth = w;
            sidebar.style.width = w + 'px';
            document.documentElement.style.setProperty('--sidebar-w', w + 'px');
            scheduleLocalAutosave();
            if (isGraphActivePane()) resizeCanvas();
        }

        // Override: Save/Load now supports full projects (still accepts old graph-only JSON)
        function saveToFile() {
            const obj = projectExportObject();
            const jsonStr = JSON.stringify(obj, null, 2);

            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'narrative_project_' + new Date().toISOString().slice(0, 10) + '.json';
            a.click();
            URL.revokeObjectURL(url);

            lastSavedState = jsonStr;
            hasUnsavedChanges = false;
            updateSaveIndicator();
            scheduleLocalAutosave();
        }

        function loadProjectObject(obj) {
            // Convert export object into in-memory project
            project = {
                version: obj.project_version || '0.1',
                title: obj.title || 'Project',
                graphs: (obj.graphs || []).map(g => ({
                    id: g.id || uid('graph'),
                    name: g.name || 'Graph',
                    data: g.data || { nodes: [], connections: [], metadata: { version: '3.2', created: new Date().toISOString(), nodeCounter: 0, attachOrderCounter: 0 } },
                    view: g.view || { panX: 0, panY: 0, zoom: 1 },
                    history: { undoStack: [], redoStack: [] }
                })),
                entities: obj.entities || { characters: [], items: [], locations: [], variables: [], notes: [] },
                ui: ensureExpandedDefaults(obj.ui || {})
            };

            // Ensure variables array exists
            if (!project.entities.variables) project.entities.variables = [];
            initRuntimeVariables();
            ensureNav(project);

            const gid = project.ui.selectedGraphId && project.graphs.find(g => g.id === project.ui.selectedGraphId)
                ? project.ui.selectedGraphId
                : (project.graphs[0]?.id || null);

            project.ui.selectedGraphId = gid;
            project.ui.selection = { kind: 'graph', id: gid };

            // UI
            projectTitleEl.textContent = project.title;
            if (project.ui.sidebarCollapsed) sidebar.classList.add('collapsed'); else sidebar.classList.remove('collapsed');
            applySidebarWidth(project.ui.sidebarWidth || 280);

            // Load first graph
            if (gid) applyGraphFromProject(gid, { skipPersist: true });

            renderSidebarTree();
            initProjectHistory();
            scheduleLocalAutosave();
        }

        function loadFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (hasUnsavedChanges) {
                if (!confirm('You have unsaved changes. Load anyway?')) {
                    event.target.value = '';
                    return;
                }
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const obj = JSON.parse(e.target.result);

                    // Project format
                    if (obj && Array.isArray(obj.graphs) && obj.entities) {
                        loadProjectObject(obj);
                        hasUnsavedChanges = false;
                        updateSaveIndicator();
                        event.target.value = '';
                        return;
                    }

                    // Old graph-only format (load into current graph)
                    if (obj && Array.isArray(obj.nodes) && Array.isArray(obj.connections)) {
                        persistCurrentGraphIntoProject();
                        // Replace data of current graph
                        const gid = project.ui.selectedGraphId || project.graphs[0]?.id;
                        const g = project.graphs.find(x => x.id === gid);
                        if (g) {
                            g.data = obj;
                            g.view = { panX: 0, panY: 0, zoom: 1 };
                            g.history = { undoStack: [], redoStack: [] };
                            applyGraphFromProject(g.id);
                            initHistory();
                        }
                        hasUnsavedChanges = false;
                        updateSaveIndicator();
                        event.target.value = '';
                        scheduleLocalAutosave();
                        return;
                    }

                    alert('Invalid JSON file format.');
                } catch (err) {
                    alert('Error reading file: ' + err.message);
                } finally {
                    event.target.value = '';
                }
            };
            reader.readAsText(file);
        }

        function exportData() {
            const obj = projectExportObject();
            const jsonStr = JSON.stringify(obj, null, 2);
            console.log(jsonStr);

            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'narrative_project_export.json';
            a.click();
            URL.revokeObjectURL(url);

            alert('Project JSON exported to console and downloaded!');
        }

        // Ensure history commits also autosave (patched at init to avoid recursion)
        function patchCommitHistoryAutosave() {
            try {
                const original = commitHistory;
                if (typeof original !== 'function') return;
                if (original._autosavePatched) return;

                const wrapped = function () {
                    original.apply(this, arguments);
                    scheduleLocalAutosave();
                };

                wrapped._autosavePatched = true;
                original._autosavePatched = true;

                commitHistory = wrapped;
            } catch (e) { }
        }
        function initProjectApp() {
            // Theme already handled elsewhere
            patchCommitHistoryAutosave();
            projectTitleEl.textContent = 'Project';

            const loaded = loadProjectFromLocal();
            if (loaded) {
                loadProjectObject(loaded);
                initRuntimeVariables();
            } else {
                // Create a starter project from the demo graph
                resetView();
                initDemo();

                project = {
                    version: '0.1',
                    title: 'Project',
                    graphs: [{
                        id: uid('graph'),
                        name: 'Main Flow',
                        data: getDataObject(),
                        view: { panX: view.panX, panY: view.panY, zoom: view.zoom },
                        history: { undoStack: [], redoStack: [] }
                    }],
                    entities: { characters: [], items: [], locations: [], variables: [], notes: [] },
                    nav: null,
                    ui: ensureExpandedDefaults({ sidebarWidth: 280, sidebarCollapsed: false, expanded: {}, selectedGraphId: null })
                };

                // Ensure variables array exists
                if (!project.entities.variables) project.entities.variables = [];

                ensureNav(project);

                project.ui.selectedGraphId = project.graphs[0].id;
                project.ui.selection = { kind: 'graph', id: project.graphs[0].id };

                // Load graph into canvas and init history
                applyGraphFromProject(project.graphs[0].id, { skipPersist: true });
                initHistory();

                // Sidebar UI
                applySidebarWidth(project.ui.sidebarWidth);
                renderSidebarTree();
                initProjectHistory();
                scheduleLocalAutosave();
            }

            initSidebarInteractions();
            // Track focus area for keyboard routing (sidebar vs graph)
            sbTree?.addEventListener('mousedown', () => { lastFocusArea = 'sidebar'; }, true);
            sidebar?.addEventListener('mousedown', () => { lastFocusArea = 'sidebar'; }, true);
            graphPane?.addEventListener('mousedown', () => { lastFocusArea = 'graph'; }, true);
            canvasContainer?.addEventListener('mousedown', () => { lastFocusArea = 'graph'; }, true);
            entityPane?.addEventListener('mousedown', () => { lastFocusArea = 'sidebar'; }, true);
            bindEntityEditor();
            initRuntimeVariables();
            resizeCanvas();
            applyViewTransform();
            requestFrame();
        }


        window.addEventListener('beforeunload', (e) => {
            if (hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                return e.returnValue;
            }
        });

        function initDemo() {
            nodesContainer.innerHTML = '';
            nodes = [];
            connections = [];
            selectedNode = null;
            clearSelectedEndpoint();
            nodeIdCounter = 0;
            attachOrderCounter = 0;

            const a = nextNodeIdentity();
            nodes.push(new Node(
                a.id, a.number,
                'Survivor Awakens',
                [
                    { text: 'You wake on a beach. Footprints lead inland.' },
                    { text: 'Strange sounds echo from the jungle.' }
                ],
                100, 200, 'purple', 'normal'
            ));

            const b = nextNodeIdentity();
            nodes.push(new Node(
                b.id, b.number,
                'Player Decision',
                [
                    { speaker: 'Player', text: 'Follow the footprints' },
                    { speaker: 'Player', text: 'Search the beach' },
                    { speaker: 'Player', text: 'Build shelter' },
                    { speaker: 'Player', text: 'Call for help' }
                ],
                100, 400, 'blue', 'character'
            ));

            const c = nextNodeIdentity();
            nodes.push(new Node(
                c.id, c.number,
                'Jungle Path',
                [
                    { text: 'The path grows darker' },
                    { text: 'You hear movement ahead' }
                ],
                500, 300, 'blue', 'normal'
            ));

            const d = nextNodeIdentity();
            nodes.push(new Node(
                d.id, d.number,
                'Find Supplies',
                [
                    { text: 'An old backpack lies in the sand' }
                ],
                500, 480, 'green', 'normal'
            ));

            connections = [
                { from: { nodeId: b.id, lineIndex: 0 }, to: { nodeId: c.id } },
                { from: { nodeId: b.id, lineIndex: 1 }, to: { nodeId: d.id } }
            ];

            applyAttachments();
            updateConnectionVisuals();
            hasUnsavedChanges = false;
            updateSaveIndicator();
            markDrawDirty(); initHistory();
        }

        function resetDemo() {
            if (hasUnsavedChanges) {
                if (!confirm('You have unsaved changes. Reset to demo anyway?')) return;
            }
            resetView();
            initDemo();
        }

        function exportData() {
            const data = getDataObject();
            const jsonStr = JSON.stringify(data, null, 2);
            console.log(jsonStr);

            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'narrative_export.json';
            a.click();
            URL.revokeObjectURL(url);

            alert('JSON exported to console and downloaded!');
        }


        // ---- Final overrides: project-aware Save/Load/Export (wins over earlier defs) ----
        saveToFile = function () {
            if (project) {
                const obj = projectExportObject();
                const jsonStr = JSON.stringify(obj, null, 2);

                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'narrative_project_' + new Date().toISOString().slice(0, 10) + '.json';
                a.click();
                URL.revokeObjectURL(url);

                lastSavedState = jsonStr;
                hasUnsavedChanges = false;
                updateSaveIndicator();
                scheduleLocalAutosave();
            } else {
                // Fallback: graph-only
                const data = getDataObject();
                const jsonStr = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'narrative_flow_' + new Date().toISOString().slice(0, 10) + '.json';
                a.click();
                URL.revokeObjectURL(url);

                lastSavedState = jsonStr;
                hasUnsavedChanges = false;
                updateSaveIndicator();
            }
        };

        loadFromFile = function (event) {
            const file = event.target.files[0];
            if (!file) return;

            if (hasUnsavedChanges) {
                if (!confirm('You have unsaved changes. Load anyway?')) {
                    event.target.value = '';
                    return;
                }
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const obj = JSON.parse(e.target.result);

                    // Project format
                    if (obj && Array.isArray(obj.graphs) && obj.entities) {
                        loadProjectObject(obj);
                        hasUnsavedChanges = false;
                        updateSaveIndicator();
                        scheduleLocalAutosave();
                        return;
                    }

                    // Old graph-only format (load into current graph)
                    if (obj && Array.isArray(obj.nodes) && Array.isArray(obj.connections)) {
                        if (!project) {
                            // create minimal project shell
                            resetView();
                            loadDataObject(obj);
                            initHistory();
                            project = {
                                version: '0.1',
                                title: 'Project',
                                graphs: [{
                                    id: uid('graph'),
                                    name: 'Main Flow',
                                    data: obj,
                                    view: { panX: 0, panY: 0, zoom: 1 },
                                    history: { undoStack: [], redoStack: [] }
                                }],
                                entities: { characters: [], items: [], locations: [], variables: [], notes: [] },
                                ui: ensureExpandedDefaults({ sidebarWidth: 280, sidebarCollapsed: false, expanded: {}, selectedGraphId: null })
                            };
                            project.ui.selectedGraphId = project.graphs[0].id;
                            project.ui.selection = { kind: 'graph', id: project.graphs[0].id };
                            currentGraphId = project.graphs[0].id;
                            // Ensure variables array exists
                            if (!project.entities.variables) project.entities.variables = [];
                            renderSidebarTree();
                            scheduleLocalAutosave();
                        } else {
                            persistCurrentGraphIntoProject();
                            const gid = project.ui.selectedGraphId || project.graphs[0]?.id;
                            const g = project.graphs.find(x => x.id === gid);
                            if (g) {
                                g.data = obj;
                                g.view = { panX: 0, panY: 0, zoom: 1 };
                                g.history = { undoStack: [], redoStack: [] };
                                applyGraphFromProject(g.id);
                                initHistory();
                            }
                        }

                        hasUnsavedChanges = false;
                        updateSaveIndicator();
                        scheduleLocalAutosave();
                        return;
                    }

                    alert('Invalid JSON file format.');
                } catch (err) {
                    alert('Error reading file: ' + err.message);
                } finally {
                    event.target.value = '';
                }
            };
            reader.readAsText(file);
        };

        exportData = function () {
            if (project) {
                const obj = projectExportObject();
                const jsonStr = JSON.stringify(obj, null, 2);
                console.log(jsonStr);

                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'narrative_project_export.json';
                a.click();
                URL.revokeObjectURL(url);

                alert('Project JSON exported to console and downloaded!');
            } else {
                // Fallback: graph-only
                const data = getDataObject();
                const jsonStr = JSON.stringify(data, null, 2);
                console.log(jsonStr);

                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'narrative_flow_export.json';
                a.click();
                URL.revokeObjectURL(url);

                alert('Graph JSON exported to console and downloaded!');
            }
        };


        
        // ---- Resizable right-side controls panel ----
        function initControlsResizer() {
            const panel = document.getElementById('rightControlsPanel') || document.querySelector('#graph-pane .controls');
            if (!panel) return;

            // Restore prior width if present
            const stored = localStorage.getItem('rightControlsPanelWidth');
            if (stored && !isNaN(parseFloat(stored))) {
                panel.style.width = `${parseFloat(stored)}px`;
            }

            const handle = document.getElementById('controlsResizer');
            if (!handle) return;

            const MIN_W = 240; // px
            const MAX_W_PX = 700; // hard cap
            const maxForViewport = () => Math.min(MAX_W_PX, Math.floor(window.innerWidth * 0.65));

            let resizing = false;
            let startX = 0;
            let startW = 0;

            const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

            handle.addEventListener('pointerdown', (e) => {
                resizing = true;
                startX = e.clientX;
                startW = panel.getBoundingClientRect().width;
                try { handle.setPointerCapture(e.pointerId); } catch (_) {}
                document.body.classList.add('resizing');
                e.preventDefault();
                e.stopPropagation();
            });

            handle.addEventListener('pointermove', (e) => {
                if (!resizing) return;
                const deltaX = e.clientX - startX;
                // drag left => bigger width; drag right => smaller width
                let newW = startW - deltaX;
                newW = clamp(newW, MIN_W, maxForViewport());
                panel.style.width = `${newW}px`;
                localStorage.setItem('rightControlsPanelWidth', String(Math.round(newW)));
                e.preventDefault();
                e.stopPropagation();
            });

            const stop = (e) => {
                if (!resizing) return;
                resizing = false;
                document.body.classList.remove('resizing');
                e && e.preventDefault && e.preventDefault();
                e && e.stopPropagation && e.stopPropagation();
            };

            handle.addEventListener('pointerup', stop);
            handle.addEventListener('pointercancel', stop);

            // Keep within bounds when window resizes
            window.addEventListener('resize', () => {
                const w = panel.getBoundingClientRect().width;
                const maxW = maxForViewport();
                if (w > maxW) {
                    panel.style.width = `${maxW}px`;
                    localStorage.setItem('rightControlsPanelWidth', String(Math.round(maxW)));
                }
            });
        }

window.addEventListener('load', () => {
            initTheme();
            initProjectApp();
                    initControlsResizer();
});

        window.addEventListener('resize', () => {
            if (isGraphActivePane()) resizeCanvas();
        });
    </script>
</body>

</html>
